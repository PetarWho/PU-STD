<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="style.css">
</head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode" />
<title>23.10.2023 Test 1</title>
<link rel="icon" href="../../2324-pics/icon.png" type="image/x-icon">

<body>
    <div class="search_box">
        <form action="" id="form2">
            <h1>Search</h1>
            <div class>
                <input type="text" id="search" class="textBox">
                <input type="button" id="submit_form" class="btn" onclick="checkInput()" value="Find next">
            </div>
        </form>
    </div>

    <script>
        function checkInput() {
            var query = document.getElementById('search').value;
            window.find(query);
            return true;
        }
    </script>
    <a class="go-to-btn" href="../Test2/index.html">Go To Test 2</a>
    <p class="heading2">Лекции 1-8</p>
    <!-- <a href="">Go To Test 2</a> -->

    <!-- lekciq 1 -->

    <div class="lekciq lekciq1">
        <p class="heading">Лекция 1 - Въведение</p>
        <div class="box">
            <h2>DESING PATTERNS (ШАБЛОНИ ЗА ДИЗАЙН):</h2>
            <h3><span>Дефиниции:</span> <br>
                … описва проблем, появяващ се отново и отново в
                нашата среда, и след това описва същината на
                решението на този проблем по такъв начин, че
                решението може да се използва милион пъти, без някога
                да се повтори начина на изпълнение [Alexander].<br>
                … концепция, предназначена за разрешаване на често
                срещани проблеми в обектно-ориентираното
                програмиране. Тази концепция предлага стандартни
                решения за архитектурни и концептуални проблеми в
                компютърното програмиране [Wikipedia].<br>
                … черпене от конкретна форма, която запазва
                повтарящи се специфични контексти [Riehle]<br>
                … и двете неща - проблем и инструкции за решаване
                на проблема [Coplien, Software Design Patterns:
                Common questions and Answers]<br>
                … литературен формат за улавяне на мъдростта и
                опита на експерти в дизайна, и представянето им на
                новаците.</h3>
            <h3><span>Свойства:</span> <br>
                - Шаблоните за дизайн:<br>
                > предоставят общ речник<br>
                > предоставят "стенография" за ефективна комуникация по
                сложни въпроси<br>
                > подпомагат документирането на софтуерни архитектури<br>
                > представят съществните части на дизайна в компактна форма<br>
                > показват повече от едно решение<br>
                > описват софтуерни абстракции.<br>
                - Шаблоните за дизайн НЕ:<br>
                > осигуряват конкретни решения<br>
                > решават всички проблеми на дизайна<br>
                > се прилагат само за обектно-ориентиран дизайн.</h3>
            <h3><span>ВИДОВЕ СОФТУЕРНИ ШАБЛОНИ (SOFTWARE PATTERNS)</span> <br>
                - Design patterns (софтуерен дизайн)<br>
                > Architectural (дизайн на системи)<br>
                > Design (микро-архитектури)<br>
                > Idioms (ниско ниво).<br>
                - Analysis patterns (повтарящи се и преизполваеми
                аналитични модели)<br>
                - Organization patterns (структура на
                организации/проекти)<br>
                - Process patterns (дизайн на софтуерен процес)<br>
                - Domain-specific patterns и др.</h3>
            <h3><span>PATTERN CATALOG AND SYSTEM</span> <br>
                - pattern catalog (каталог на шаблони за дизайн)<br>
                > колекция от свързани шаблони, които са групирани в
                категории.<br>
                - pattern system (система, изпозлваща шаблони за
                дизайн)<br>
                > ... единен набор от свързани модели, които работят заедно,
                за да поддържат изграждането и развитието на цели
                архитектури ...</h3>
            <h3><span>OBJECT ORIENTED DESIGN PATTERN</span> <br>
                - Шаблон за дизайн е описание на комуникиращи
                обекти и класове, които са персонализирани с цел
                решаване на общ проблем на дизайна, в конкретен
                контекст.<br>
                - Един шаблон включва четири компонента:<br>
                > Име<br>
                > Проблем<br>
                > Решение<br>
                > Следствия </h3>
            <h3><span>ИМЕ НА ШАБЛОНА ЗА ДИЗАЙН</span> <br>
                - Описва проблема на дизайна и неговите решения
                в една или две думи<br>
                - Използва се в документацията<br>
                - Увеличава нашия речник<br>
                - Трябва да бъде ясно и говоримо</h3>
            <h3><span>ПРОБЛЕМ</span> <br>
                - Описва кога да се прилага шаблона<br>
                - Обяснява проблема и неговия контекст<br>
                - Понякога включва списък на условията, които трябва да
                бъдат изпълнени, за да има смисъл използването на
                шаблона<br>
                - Трябва да се случва/появява отново и отново</h3>
            <h3><span>РЕШЕНИЕ</span> <br>
                - Описва елементите, които съставляват дизайна,<br>
                > техните взаимоотношения,<br>
                > отговорности, и<br>
                > сътрудничества.<br>
                - Не описва конкретен дизайн или имплементация<br>
                - Трябва да бъде доказан чрез успешни проекти</h3>
            <h3><span>СЛЕДСТВИЯ</span> <br>
                - Резултати и компромиси при прилагането на
                шаблона<br>
                - Полезен за:<br>
                > описване на дизайнерски решения<br>
                > оценка на алтернативни дизайни<br>
                - Предимства от прилагането на шаблона<br>
                - Въздействие върху система по отношение на<br>
                гъвкавост, разширяемост и / или преносимост</h3>
            <h3><span>GOF ФОРМАТ ЗА ОПИСАНИЕ НА ШАБЛОНИ ЗА ДИЗАЙН</span> <br>
                - Pattern name and classification - име и класификация на
                шаблона<br>
                - Intent – цел, какво прави шаблона / кога върши работа<br>
                - Also known as – други известни имена на шаблона (ако има)<br>
                - Motivation - проблемът на дизайна / как структури от
                класове и обекти решават проблема<br>
                - Applicability – приложимост, ситуации, в които може да
                бъде използван шаблона<br>
                - Structure - графично представяне на класовете в шаблона</h3>
            <h3><span>СТРУКТУРА</span> <br>
                - Participants – описание на класовете и обектите на
                шаблона и техните отговорности<br>
                - Collaborations – взимодействия между участниците при
                изпълнение на техните отговорности<br>
                - Consequences – следствия, предимства и недостатъци<br>
                - Implementation – имплементация, съвети, техники<br>
                - Sample code – примерен код, показващ възможна
                имплементация<br>
                - Known uses – шаблони, открити в реални системи<br>
                - Related patterns – тясно свързани шаблони</h3>
            <h3><span>ШАБЛОНИ ЗА ДИЗАЙН - КАТЕГОРИЗАЦИЯ</span> <br>
                - Създаващи шаблони (Creational patterns) са тези, които
                създават обекти. Това дава на програмата по-голяма
                гъвкавост при вземането на решения какви обекти трябва
                да бъдат създадени за всеки отделен случай.
                - Структурните шаблони (Structural patterns) помагат да се
                композират групи от обекти в по-големи и сложни
                структури, като например сложни потребителски
                интерфейси.
                - Поведенческите шаблони (Behavioral patterns) помагат да
                се определи комуникацията между обектите и контрола на
                потока в една комплексна система.</h3>
        </div>
    </div>


    <!-- lekciq 2 -->

    <div class="lekciq lekciq2">
        <p class="heading">Лекция 2 - Abstract Factory, Builder</p>
        <div class="box">
            <h2>CREATIONAL PATTERNS (ГРАДИВНИ ШАБЛОНИ)</h2>
            <h3>Abstract Factory<br>
                Builder<br>
                Factory Method<br>
                Prototype<br>
                Singleton</h3>
        </div>

        <div class="box">
            <h2>Abstract Factory (АБСТРАКТНА ФАБРИКА)</h2>
            <h3><span>Цел:</span> <br> Доставя интерфейс за създаване на
                семейства от свързани или зависими обекти, без
                да се специфицират техните конкретни класове.</h3>
            <h3><span>УПОТРЕБА: </span><br>
                Подходящо е да се използва в следните случаи: <br>
                - една система трябва да бъде независима от това, как
                се създават, композират и представят нейните
                продукти<br>
                - една система трябва да бъде конфигурирана с една
                от няколко групи продукти<br>
                - проектирано е група от свързани продукти да бъдат
                използвани заедно, и това ограничение трябва да се
                наложи стриктно<br>
                - искате да предоставите библиотеки от класове за
                продукти, като разкриете само техните интерфейси,
                без имплементацията им.</h3>
            <h3><span>СТРУКТУРА НА ШАБЛОНА: </span><br>
                - AbstractFactory - декларира интерфейс с методи за
                създаване на абстрактни продукти <br>
                - ConcreteFactory - имплементира операциите за
                създаване на конкретни продукти <br>
                - AbstractProduct - декларира интерфейс за клас
                продукти <br>
                - ConcreteProduct - дефинира продукт, който да бъде
                създаден от конкретна фабрика; имплементира
                интерфейса AbstractProduct <br>
                - Client - използва само интерфейси, декларирани чрез
                AbstractFactory и AbstractProduct класове.</h3>
            <h3><span>ВЗАИМОДЕЙСТВИЯ:</span> <br>
                - Обикновено в рънтайма се създава една единствена
                инстанция на класа ConcreteFactory. Тази конкретна
                фабрика създава продукти, които имат специфична
                имплементация. За да създадат различни групи
                продукти, клиентите трябва да използват различни
                конкретни фабрики. <br>
                - AbstractFactory отлага създаването на продукти, то се
                извършва от подкласа ConcreteFactory.</h3>
            <h3><span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span> <br>
                - Изолира конкретните класове. Една фабрика
                капсулира дейностите по създаване на продукти, и по
                този начин изолира клиентите от имплементацията
                на класовете. Клиентите манипулират инстанциите
                чрез техните абстрактни интерфейси. Имената на
                класовете на продуктите са изолирани в
                имплеметацията на конкретната фабриката; те не се
                появяват никъде в клиентския код. <br>
                - Лесна замяна на групи продукти. Класът на
                конкретна фабрика се появява само веднъж в кода на
                приложението - където се създава нейна инстанция.
                Това позволява лесна промяна на фабриката,
                съответно на цяла група продукти. Тъй като една
                абстрактна фабрика създава цяла група от продукти,
                цялата група продукти се променя наведнъж. <br>
                - Добавянето на нови видове продукти не е лесно.
                AbstractFactory интерфейса фиксира множество от
                продукти, които могат да бъдат създавани. Добавянето
                на нови видове продукти изисква разширяване на
                интерфейса AbstractFactory, което води след себе си до
                промяна на всички класове, които го наследяват. <br>
                - Налага съгласуваност между продукти. Когато е
                проектирано група продукти да работят заедно, е
                важно приложението да използва обектите от само
                една група в даден момент. AbstractFactory позволява
                лесно да се наложи това ограничение.</h3>
            <h3><span>ВРЪЗКА С ДРУГИ ШАБЛОНИ: </span> <br>
                - AbstractFactory класовете често се имплементират с
                Factory Method, може да се използва и Prototype. <br>
                - Конкретна фабрика често е удачно да се реализира с
                шаблона Singleton.</h3>
        </div>

        <div class="box">
            <h2>BUILDER (СТРОИТЕЛ)</h2>
            <h3><span>Цел:</span> <br>
                - Разделя процеса на създаването на сложен продукт
                от неговото представяне. <br>
                - Един и същи процес за създаване на продукт може
                да създаде продукт с различни представяния.</h3>
            <h3><span>УПОТРЕБА: </span><br>
                Подходящо е да се използва в следните случаи: <br>
                - алгоритъмът за създаване на сложен обект трябва да
                бъде независим от частите, от които е съставен
                обекта и начина, по който е асемблиран. <br>
                - процесът на конструиране трябва да позволи
                различни представяния на обекта.</h3>
            <h3><span>СТРУКТУРА НА ШАБЛОНА: </span><br>
                - Builder - абстрактен интерфейс за създаване на части от
                продукт <br>
                - ConcreteBuilder
                > конструира и асмеблира части на продукта чрез имплементиране
                на интерфейса Builder <br>
                > дефинира и следи за създаваните от него представяния <br>
                > предоставя интерфейс за извличане на продукта.<br>
                - Director - конструира обект, като използва интерфейса Builder <br>
                - Product<br>
                > представлява сложния обект, който се изгражда. ConcreteBuilder
                създава вътрешното представяне на продукта и дефинира
                процеса на неговото асемблиране <br>
                > включва класове, дефиниращи съставните части, включително
                интерфейсите за асемблиране на частите до крайния резултат.</h3>
            <h3><span>ВЗАИМОДЕЙСТВИЯ:</span> <br>
                - Клиентът създава обект Director и го конфигурира с
                желания Builder обект.
                - Director уведомява builder, когато трябва да се
                изгради някоя част от продукта.
                - Builder обработва заявките от director-а и добавя
                частите към продукта.
                - Клиентът извлича продукта от builder-а.</h3>
            <h3><span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span> <br>
                - Позволява да се променя вътрешното представяне
                на продукт. Обектът Builder доставя на director-а
                абстрактен интерфейс за изграждане на продукт.
                Интерфейсът позволява на builder-а да скрие
                представянето и вътрешната структурата на продукта.
                Той скрива и как е асемблиран продукта. Тъй като
                продуктът се конструира чрез абстрактен интерфейс,
                всичко, което трябва да се направи, за да се промени
                вътрешното представяне на продукта, е да се
                дефинира нов вид builder.<br>
                - Изолира кода за конструиране и представяне.
                Шаблонът Builder подобрява модулността чрез
                капсулиране на начина, по който се конструира и
                представя сложен обект. Клиентите не трябва да знаят
                нищо за класовете, които дефинират вътрешната
                структура на продукта (такива класове не са включени
                в интерфейса на Builder-а). <br>
                Всеки ConcreteBuilder съдържа всичкия код за
                създаване и асемблиране на конкретен вид продукт.
                Кодът е написан веднъж; след това различни Director
                обекти могат да го използват многократно, за да
                изградят различни варианти на продукта от един и
                същи набор от части.<br>
                - Има силен контрол върху процеса на изграждане
                на обект. За разлика от градивните паблони, които
                изграждат продукти “наведнъж”, шаблонът Builder
                конструира продукт стъпка по стъпка под контрола
                на director-а. Чак след като продуктът е завършен,
                director го взема от builder-а. По този начин
                интерфейса Builder рефлектира върху процеса на
                конструиране на продукта повече отколкото другите
                градивни шаблони. Това дава по-прецизен контрол
                върху процеса на изграждане и следователно на
                вътрешната структура на изграждания продукт.
            </h3>
            <h3><span>ВРЪЗКА С ДРУГИ ШАБЛОНИ: </span> <br>
                - Abstract Factory прилича на Builder по това, че
                също може да изгради сложни обекти. Основната
                разлика е, че шаблона Builder е фокусиран върху
                изграждане на сложен обект стъпка по стъпка.
                Акцента на Abstract Factory е върху групи от
                продукти (прости или сложни). Builder връща
                продуктa като крайна стъпка, за разлика от
                шаблона Abstract Factory, където продукта се
                връща веднага. <br>
                - Често обекта, изграден от Builder е Composite.</h3>
        </div>
    </div>


    <!-- lekciq 3 -->

    <div class="lekciq lekciq3">
        <p class="heading">Лекция 3 - FACTORY METHOD, PROTOTYPE, SINGLETON</p>
        <div class="box">
            <h2>CREATIONAL PATTERNS (ГРАДИВНИ ШАБЛОНИ)</h2>
            <h3>Abstract Factory<br>
                Builder<br>
                Factory Method<br>
                Prototype<br>
                Singleton</h3>
        </div>
        <div class="box">
            <h2>FACTORY METHOD (МЕТОД ФАБРИКА)</h2>
            <h3> <span>Цел:</span><br>
                Дефинира интерфейс за създаване на обект, но
                позволява на подкласовете да решат кой клас да
                инстанцират. Factory Method позволява на един клас
                да отложи инстанцирането за подкласовете.</h3>
            <h3> <span>Известен и като:</span><br>
                Virtual Constructor (Виртуален конструктор)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - един клас не може да предвиди класа на обектите,
                които трябва да създаде<br>
                - един клас иска неговите подкласове да определят
                обектите, които той създава<br>
                - класове делегират отговорност на един от няколко
                помощни подкласа, и искате да локализирате
                знанието кой е конкретния подклас. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Product - дефинира интерфейса на обектите,
                създавани от метода фабрика.<br>
                - ConcreteProduct – имплементира интерфейса
                Product.<br>
                - Creator<br>
                > декларира метода фабрика, който връща обект от тип
                Product. Creator може също да дефинира
                имплементация по подразбиране на метода фабрика,
                който връща ConcreteProduct обект по подразбиране<br>
                > може да извика метода фабрика, за да създаде обект Product.<br>
                - ConcreteCreator<br>
                > предефинира метода фабрика, така, че да върне
                инстанция на съответния ConcreteProduct</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Creator разчита на неговите подкласове да
                дефинират метода фабрика така, че той да може да
                върне инстанция на съответния ConcreteProduct.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Методите фабрики елиминират необходимостта от
                използване на специфични за приложенията класове във
                вашия код. В кода се използва само интерфейса Product,
                следователно може да работи със всички дефинирани от
                потребителите ConcreteProduct класове.<br>
                - Предоставя точки за закачане за подкласове.
                Създаването на обекти в клас с метод-фабрика винаги е
                по-гъвкаво, отколкото директно създаване на обект.
                Методът фабрика дава на подкласовете възможност за
                предоставяне на разширена версия на даден обект.<br>
                - Свързва паралелни йерархии от класове. В
                разгледания пример метода фабрика се извиква само от
                Creators. Но в общия случай клиентите могат да
                извлекат полза в случаи на паралелни йерархии от
                класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Abstract Factory често се имплементира чрез Factory
                Methods.<br>
                - Factory Methods обикновено се извикват от
                шаблонни методи (Template Methods).<br>
                - Prototypes не изискват да се създават подкласове на
                Creator. Въпреки това, те често изискват операция
                Initialize в класа Product. Creator използва Initialize да
                инициализира обекта. Factory Method не изисква
                такава операция.</h3>
        </div>
        <div class="box">
            <h2>PROTOTYPE (ПРОТОТИП)</h2>
            <h3> <span>Цел:</span><br>
                Специфицира вида на обектите, които създава,
                с помощта на прототипна инстанция, и създава нови
                обекти чрез копиране на този прототип.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Prototype, когато една система трябва
                да е независима от това как се създават, композират и
                представят нейните продукти, и освен това:<br>
                - когато класовете, които трябва да се инстанцират, се
                специфицират в рън-тайма (напр. при динамично
                зареждане), или<br>
                - за да избегнете изграждането на йерархия от класове
                фабрики, която да е паралелна на йерархия от класове
                продукти, или<br>
                - когато инстанциите на един клас може да имат едно от
                няколко различни състояния. В този случай може да е поудобно да инсталирате съответния брой прототипи и
                да ги
                клонирате, вместо да инстанциирате класа ръчно всеки път
                в съответното състояние. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Prototype - декларира интерфейс за клонирането си.<br>
                - ConcretePrototype – имплементира операция за
                клонирането си.<br>
                - Client - създава нов обект, като кара прототипа да се
                клонира.<br>
                Основната отговорност на шаблона Prototype е всеки подклас
                на Prototype да имплементира операцията Clone.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиент иска даден прототип да се клонира.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Prototype има много от предимствата на Abstract Factory
                и Builder: скрива конкретните класове на продукта от
                клиента, като по този начин намалява броят на
                имената, които клиентите знаят. Тези шаблони
                позволяват на клиента да работи със спефични за
                приложенията класове, без да е необходима промяна.<br>
                - Добавяне и премахване на продукти в рън-тайма.
                Прототипите позволяват включване на нов
                конкретен клас продукти в една система просто чрез
                регистриране на прототипна инстанция в клиента.
                Това е малко по-гъвкаво от другите градивни
                шаблони, защото клиента може да инсталира и
                премахва прототипи в рън-тайма.<br>
                - Специфициране на нови обекти чрез промяна на
                стойностите. Силно динамичните системи позволяват
                дефиниране на ново поведение посредством композиране
                на обекти, напр. чрез специфициране на стойности за
                променливите на даден обект (вместо чрез дефиниране на
                нови класове). Може ефективно да се дефинират нови
                видове обекти чрез инстанцииране на съществуващи
                класове и регистриране на инстанциите като прототипи на
                обекти на клиента. Всеки клиент може да покаже ново
                поведение като делегира отговорността на прототипа.<br>
                Този вид дизайн позволява на потребителите да дефинират
                нови "класове" без програмиране. В действителност,
                клонирането на прототип е подобно на инстанциране на клас.
                Шаблонът Prototype може значително да редуцура броя на
                класовете, от които се нуждае приложението.<br>
                - Специфициране на нови обекти чрез промяна на
                структурата. За целта е необходимо само да се
                добави нов обект като прототип.<br>
                - Редуциране на подкласовете. Factory Method
                често произвежда йерархия на Creator класове,
                която е паралелна на йерархията от класове
                продукти. Шаблонът за дизайн Prototype позволява
                да се клонира prototype вместо да искате някой
                factory method да направи нов обект. Т.е. не е
                необходима йерархия от Creator класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Prototype и Abstract Factory са конкурентни шаблони
                в някои отношения, но те могат да се използват и
                заедно. Abstract Factory може да съхранява
                множество от прототипи, от които да клонира и
                връща обекти продукти.<br>
                - Дизайни, които използват интензивно шаблони за
                дизайн Composite и Decorator, често могат да
                извлекат полза от Prototype.</h3>
        </div>
        <div class="box">
            <h2>SINGLETON (СЕК)</h2>
            <h3> <span>Цел:</span><br>
                Осигурява клас, който е проектиран да има
                само една инстанция, и предоставя глобална точка за
                достъп до нея.</h3>
            <h3> <span>МОТИВАЦИЯ:</span><br>
                - За някои класове е важно да имат точно една
                инстанция.<br>
                - Напр. в една система може да има много принтери,
                но трябва да има само един мениджър на принтери.<br>
                - Възможно е да използва клас, който сам да е
                отговорен за следенето на единствената си
                инстанция. Класът може да гарантира, че не може да
                се създаде друга инстанция (чрез прехващане на
                заявки за създаване на нови инстанции) и да
                предостави начин за достъп до инстанцията.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Singleton в следните случаи:<br>
                - трябва да има точно една инстанция на клас, и тя
                трябва да е достъпна за клиентите чрез известна
                точка за достъп<br>
                - когато единствената инстанция трябва да бъде
                разширяема чрез създаване на подкласове и
                клиентите трябва да могат да използват
                разширените инстанции, без да променят техния
                първоначален код. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Singleton
                > дефинира операция Instance, която позволява на клиентите
                достъп до уникалната инстанция;
                > може да бъде отговорен за създаването на своята уникална
                инстанция.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиентите достъпват инстанцията на Singleton само чрез операция Instance.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Контролиран достъп до единствената инстанция. Тъй
                като класът Singleton капсулира единствената си
                инстанция, той може да има строг контрол върху това как
                и кога клиентите имат достъп до нея.<br>
                - Редуциране на name space. Шаблонът Singleton е
                подобрение спрямо глобалните променливи. Той избягва
                "натоварването" на name space с глобални променливи,
                които съхраняват единични инстанции.<br>
                - Позволява усъвършенстване на операциите и
                представянето. Класът Singleton може да бъде
                наследяван от други класове, и е лесно да се
                конфигурира приложение с инстанция на този разширен
                клас. Може да конфигурирате приложението с
                инстанцията на необходимия ви клас в рън-тайма.<br>
                - Позволява променлив брой инстанции. Възможно
                е да се разреши създаването на повече от една
                инстанция на класа Singleton. Може да се използва
                същия подход за контрол на броя на инстанциите.
                За целта е необходимо да се промени само
                операцията, която предоставя достъп до
                инстанцията на Singleton.<br>
                - Повече гъвкавост, отколкото операциите на клас.
                Друг начин за пакетиране на функционалностите на
                singleton е да се използват операции на клас. Но в
                този случай е трудно да се промени дизайна да се
                даде възможност за повече от една инстанция на
                клас.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                Много шаблони за дизайн могат да бъдат
                имплементирани с помощта на шаблона Singleton.
                Напр. Abstract Factory, Builder и Prototype.</h3>
        </div>
    </div>


    <!-- lekciq 4 -->

    <div class="lekciq lekciq4">
        <p class="heading">Лекция 4 - ADAPTER, BRIDGE, COMPOSITE</p>
        <div class="box">
            <h2>STRUCTURAL PATTERNS (СТРУКТУРНИ ШАБЛОНИ)</h2>
            <h3>- Adapter<br>
                - Bridge<br>
                - Composite<br>
                - Decorator<br>
                - Facade<br>
                - Flyweight<br>
                - Proxy</h3>
        </div>
        <div class="box">
            <h2>ADAPTER (АДАПТЕР)</h2>
            <h3> <span>Цел:</span><br>
                Преобразува интерфейса на даден клас в
                друг интерфейс, какъвто клиента очаква.<br>
                - Позволява на класове да работят заедно в
                случаите, в които е невъзможно поради
                несъвместими интерфейси.</h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Необходимо е да се използва съществуващ клас, но
                интерфейсът му не отговаря на това, което е
                необходимо<br>
                - Трябва да създадете клас с възможност за многократно
                използване, който да работи с несвързани или
                непредвидими класове (т.е. с класове, с които може да
                има несъвместими интерфейси) </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Target – дефинира конкретният интерфейс, използван от
                Client<br>
                - Client – работи с обекти, отговарящи на интерфейса на
                Target<br>
                - Adaptee – дефинира съществуващ интерфейс, нуждаещ
                се от адаптиране<br>
                - Adapter – адаптира интерфейса на Adaptee към
                интерфейса на Target.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентите извикват операции на инстанция на
                Adapter.<br>
                - Адаптерът от своя страна извиква операции на
                Adaptee, които изпълняват заявката.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Адаптира адаптирания към целевия клас, като създава
                конкретен клас адаптер. Адаптерът на класове няма да
                работи, ако искате да адаптирате даден клас и всички
                негови подкласове.<br>
                - Дава възможност на адаптера да предефинира част от
                поведението на адаптирания клас, тъй като Adapter е
                подклас на Adaptee.<br>
                - Въвежда само един обект и не е необходимо
                допълнително ниво на индирекция, за да се достигне до
                адаптирания обект.<br>
                - Какво може да адаптира Adapter? Адаптерите се
                различават по количеството работа, която
                извършват, за да адаптират Adaptee към интерфейса
                на Target. Това може да включва от проста смяна на
                имената на някои операции до поддържането на
                изцяло различен набор от операции.<br>
                - Включваеми адаптери. Вграждането на
                адаптирането на интерфейси в класа дава
                възможност за включване на класа в съществуващи
                системи, които може да очакват разлчини
                интерфейси към този клас.<br>
                - Използване на двупосочни адаптери за постигане на
                прозрачност. Един проблем е това, че адаптерите не са
                прозрачни за всички клиенти. Адаптираният обект
                вече не отговаря на интерфейса на Adaptee, така, че не
                може да се използва навсякъде вместо него.<br>
                Двупосочните адаптери (two-way adapters) могат да
                предоставят подобна прозрачност. Те са особено
                полезни, когато два различни клиента трябва да
                виждат един обект по различен начин.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Bridge е със структура, подобна на адаптер на обект,
                но с друга цел. Неговото предназначение е да отдели
                интерфейса от неговата имплементация, така че те
                да могат да се променят независимо и лесно. За
                разлика от него, Adapter има за цел да промени
                интерфейса на съществуващ обект.<br>
                - Decorator разширява друг обект, без да променя
                интерфейса му. Той е по-прозрачен за приложението,
                в сравнение с Adapter. Decorator поддържа
                рекурсивно композиране, което не е възможно при
                чистите адаптери.<br>
                - Proxy дефинира инстанция или заместител да друг
                обект, и не променя интерфейса му.</h3>
        </div>
        <div class="box">
            <h2>BRIDGE (МОСТ)</h2>
            <h3> <span>Цел:</span><br>
                Разделя абстракция от нейната имплементация,
                така че двете да могат да се променят независимо.</h3>
            <h3> <span>Известен и като:</span><br>
                Handle/Body (Манипулатор/Тяло)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да избегнете твърдо обвързване между
                дадена абстракция и нейната имплементация (напр.
                когато имплементацията трябва да се избира или
                сменя в рън-тайма).<br>
                - Както абстракциите, така и техните имплементации
                трябва да бъдат разширяеми чрез създаване на
                подкласове. В този случай шаблонът Bridge дава
                възможност за комбиниране на различни абстракции
                и имплементации и независимото им разширяване.<br>
                - Промените в имплементацията на дадена абстракция
                не трябва да влияят върху клиентите (т.е. да не се
                налага прекомпилиране на техния код).</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Abstraction:<br>
                > Дефинира интерфейса на абстракцията<br>
                > Поддържа референция към обект от тип Implementor.<br>
                - RefinedAbstraction – разширява интерфейса, дефиниран от
                Abstraction.<br>
                - Implementor – дефинира интерфейса на класовете на
                имплементацията. Този интерфейс не е задължително да
                отговаря напълно на интерфейса на Abstraction (двата
                интерфейса могат да са доста различни). Обикновенно
                интерфейсът на Implementor предоставя само елементарни
                операции, а Abstraction дефинира операции от по-високо
                ниво, базирайки се на тези елементарни операции.<br>
                - ConcreteImplementor – дефинира конкретна имплементация
                на implementor.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Abstraction препредава заявките от клиентите към
                своя обект Implementor.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Разделяне на интерфейса и имплементацията.
                Имплементацията не е обвързана твърдо с даден
                интерфейс. Тя може да бъде конфигурирана в рън-тайма,
                възможно е даже обект да смени своята имплементация в
                рън-тайма.<br>
                Разделянето на Abstraction и Implementor елиминира и
                зависимостите от имплементацията по време на
                изпълнението. Промяната на имплементациония клас не
                изисква прекомпилиране на класа Abstraction и неговите
                клиенти.<br>
                Едно такова разделяне улеснява използването на слоеве,
                съответно по-добро структуриране на системата. Частта на
                най-високо ниво в системата трябва да знае само за
                Abstraction и Implementor.<br>
                - Подобрена разширяемост. Йерархиите Abstraction и
                Implementor може да се разширяват независимо една от
                друга.<br>
                - Скриване на подробностите на имплементацията от
                клиентите. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Abstract Factory може да се създаде и конфигурира с
                конкретен Bridge.<br>
                - Шаблонът Adapter се използва, когато несвързани
                класове трябва да работят заедно. Bridge се използва
                предварително при проектирането, за да могат
                абстракциите и имплементациите да се променят
                независимо едни от други. </h3>
        </div>
        <div class="box">
            <h2>COMPOSITE (КОМПОЗИЦИЯ)</h2>
            <h3> <span>Цел:</span><br>
                Композиране на обекти в дървовидни структури
                за представяне на йерархии от елементи.<br>
                - Шаблонът дава възможност на клиентите да третират
                по един и същи начин отделни обекти и композиции
                от обекти.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да представите йерархии от съставни обекти<br>
                - Искате клиентите да могат да игнорират разликите
                между композиции от обекти и отделни обекти.
                Клиентите ще третират еднакво всички обекти в
                сложната структура.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Component<br> Декларира интерфейса на обектите в композицията<br>
                > Имплементира частите от интерфейса, общи за всички класове<br>
                > Декларира интерфейс за достъп и управление на вложени
                компоненти (наследници)<br>
                > (незадължително) дефинира интерфейс за достъп до родителя на
                даден компонент в рекурсивната структура и го имплементира, ако
                се налага.<br>
                - Leaf<br>
                > Представлява обекти листа в композицията (листата нямат
                наследници)<br>
                > Дефинира поведение за примитивните обекти в композицията.<br>
                - Composite<br>
                > дефинира поведение за компоненти с наследници<br>
                > съхранява наследници<br>
                > имплементира операции, свързани с наследници, в
                интерфейса на Component.<br>
                - Client<br>
                > манипулира обекти от композицията чрез интерфейса на
                Component.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиентите използват интерейса на класа Component,
                за да взаимодействат с обекти от композицията. Ако
                обектът е листо, заявката се обработва направо. Ако
                обектът е композиция, тя обикновенно се предава
                към компонентите наследници, евентуално
                извършвайки допълнителни операции преди и/или
                след предаването.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Дефинира класове йерархии, състоящи се от
                примитивни и сложни обекти. Примитивните обекти
                могат да бъдат композирани в по-сложни обекти, които
                от своя страна могат да бъдат композирани рекурсивно
                и т.н. Там, където кода на клиента очаква примитивен
                обект, може да приеме и композиран.<br>
                - Опростява клиента. Клиентите могат да третират
                еднакво композициите и отделните обекти. Клиентите
                обикновенно не знаят дали си имат работа с листо или
                с композиция. Това опростява клиентския код, защото
                се избягват проверки за типа на обектите от
                композицията.<br>
                - Улеснява добавянето на нови видове компоненти.
                Новодефинираните подкласове на Composite или Leaf
                работят автоматично със съществуващите структури и
                клиентски код. Не се налага промяна на клиентите за
                нови класове Component.<br>
                - Може да се направи дизайна прекалено общ.
                Улесненото добавяне на нови компоненти води до
                проблем – трудно е да се ограничат компонентите на
                композицията. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Често връзката компонент – родител се използва за шаблона
                Chain of Responcibility.<br>
                - Шаблонът Decorator често се използва с шаблона Composition.
                Когато се използват декоратори и композитори, обикновенно те
                имат общ родителски клас. Това означава, че декораторите ще
                трябва да поддържат иинтерфейса на компонента с операции
                като Add, Remove, GetChild и т.н.<br>
                - Flyweight дава възможност за поделяне на компоненти, но те
                вече няма да имат връзка към родителите си.<br>
                - Iterator може да се използва за обхождане на композиции.<br>
                - Visitor локализира операциите и поведението, което иначе би
                било разпръснато из сложните и примитивните класове на
                композицията.</h3>
        </div>
    </div>


    <!-- lekciq 5 -->

    <div class="lekciq lekciq5">
        <p class="heading">Лекция 5 - DECORATOR, FACADE, FLYWEIGHT, PROXY</p>
        <div class="box">
            <h2>STRUCTURAL PATTERNS (СТРУКТУРНИ ШАБЛОНИ)</h2>
            <h3>- Adapter<br>
                - Bridge<br>
                - Composite<br>
                - Decorator<br>
                - Facade<br>
                - Flyweight<br>
                - Proxy</h3>
        </div>
        <div class="box">
            <h2>DECORATOR (ДЕКОРАТОР)</h2>
            <h3> <span>Цел:</span><br>
                Динамично възлагане на допълнителни
                отговорности на даден обект. Декораторите предоставят
                гъвкава алтернатива на създаването на подкласове при
                разширяване на функционалността.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - За динамично и прозрачно добавяне на
                отговорности към отделни обекти, т.е. без да се
                засягат целевите обекти.<br>
                - За отговорности, които могат да се отнемат.<br>
                - Когато разширяването чрез създаване на подкласове
                не е практично. Понякога е възможен голям брой
                независими разширения и това води до експозиция
                на подклалсове, които трябва да поддържат всяка
                възможна комбинация. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Component – дефинира интерфейс за обекти, към
                които могат да се добавят динамично отговорности.<br>
                - ConcreteComponent – дефинира обект, към който
                могат да се добавят допълнителни отговорности.<br>
                - Decorator – поддържа референция към обект
                Component и дефинира интерфейс, отговарящ на
                интерфейса на Component.<br>
                - ConcreteDecorator – добавя характеристики към
                компонента.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Decorator предава заявки към своя обект Component.
                Има възможност за извършване на допълнителни
                операции преди и след предаването на заявката.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Предлага по-голяма гъвкавост от статичното
                наследяване. Предоставя по-гъвкав начин за добавяне
                на отговорности към обекти в сравнение със
                статичното (множествено) наследяване. При
                декораторите, отговорности могат да се добавят и
                махат в рън-тайма просто чрез закачането и откачането
                им. За разлика от това, наследяването изисква
                създаване на нов клас за всяка нова отговорност. Това
                води до възникване на много класове и увеличава
                сложността на системата.<br>
                - Избягва претоварването на класовете в йерархията с
                разнообразни възможности. Шаблонът предлага подход
                за добавяне на отговорности в движение. Вместо да
                поддържате всички предвидими възможности в един
                сложен клас с възможности за настройка, той дава
                възможност да дефинирате един прост клас и постепенно
                да добавяте функционалност чрез декоратори.
                Функционалността може да се композира от прости
                малки части. Създаването на нови видове декоратори е
                лесно, независимо от класовете на обектите, които
                разширяват.<br>
                - Декораторът и неговият компонент не са идентични.
                Декораторът служи като прозрачна опаковка. От гледна
                точка на идентичността на обекта, един декориран
                компонент не е идентичен със самия компонент.<br>
                - Множество малки обекти. Използването на шаблона
                Decorator често води до системи, композирани от
                множество малки обекти, които си приличат. Обектите
                се различават само по начина, по който са
                взаимосвързани, а не по типа си. Такива системи може
                да са трудни за разучаване и дебъгване</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Decorator се различава по Adapter по това, че
                адаптерът само променя задълженията на обекта, а
                не неговия интерфейс; адаптерът дава на обекта
                съвсем нов интерфейс.<br>
                - Decorator може да се разглежда като изродена
                композиция (Composition) със само един компонент.
                Декораторът обаче добавя нови задължения – той не
                е предназначен за агрегация на обекти.<br>
                - Decorator дава възможност за промяна на външността
                на даден обект; Strategy дава възможност за промяна
                на външността му. Това са два алтернативни начина
                за промяна на един обект.</h3>
        </div>
        <div class="box">
            <h2>FACADE (ФАСАДА)
            </h2>
            <h3> <span>Цел:</span><br>
                Предоставя унифициран интерфейс към набор
                интерфейси в една подсистема. Шаблонът дефинира
                интерфейс от високо ниво, който прави подсистемата
                лесна за използване.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да предоставите прост интерфейс към една
                сложна система. Подсистемите стават все по-сложни при
                своята еволюция. Използването на повечето шаблони за
                дизайн води до повече и по-малки класове. Това прави
                системата по-удобна за многократна употреба и полесна за настройка, но тя става по-трудна за използване
                от клиентите, които нямат нужда от разширениете
                възможности за настройка. Фасадата може да
                предостави прост, подразбиращ се изглед към
                подсистемата, който е достатъчен за повечето
                подклиенти. Само клиентите, имащи нужда от повече
                възможности за настройка, ще трябва да поглеждат
                отвъд фасадата.<br>
                - Има много зависимости между клиентите и
                класовете на имплементацията на една абстракция.
                Като въведете фасада, за да разделите подсистемата
                от клиентите и от другите подсистеми, ще подобрите
                независимостта и преносимостта й.<br>
                - Искате да изградите своите подсистеми на слоеве.
                Използвайте фасада, за да дефинирате входна точка
                към всяко ниво на подсистемата. Ако подсистемите
                са зависими една от друга, можете да опростите
                зависимостите, като ги накарате да комуникират
                помежу си единствено чрез своите фасади.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Facade<br>
                > знае кои класове на подсистемата отговарят за дадена заявка<br>
                > делегира клиентските заявки към съответните обекти на
                подсистемата.<br>
                - Класове на подсистемата<br>
                > имплементират функционалността на подсистемата<br>
                > извършват работа, зададена от обекта фасада<br>
                > не знаят нищо за фасадата, т.е. не пазят референции към нея.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентите комуникрат с подистемата, като изпращат
                заявки към фасадата, която ги предава към съответния
                обект/обекти от подсистемата. Обектите от
                подсистемата извършват същинската работа, но може
                да е наложи самата фасада да свърши малко работа по
                преобразуване на своя интерфейс към интерфейсите на
                подсистемата.<br>
                - Клиентите, използващи фасадата, нямат директен
                достъп до обектите на подсистемата.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Държи настрана клиентите от компонентите на
                подсистемата. По този начин се намалява броя на
                обектите, с които работи клиента и се улеснява
                използването на подсистемата.<br>
                - Не пречи на приложенията да използват класовете на
                подсистемата, ако им се налага. Така има възможност
                за избор между лесно използване и богати
                възможности.<br>
                - Постига се слабо обвързване между подсистемата и
                нейните клиенти. Това позволява промяна на
                компонентите на подсистемата, без да се засягат
                нейните клиенти. Фасадите могат да елиминират
                сложните и цикличните зависимости. Намаляването на
                зависимостите при компилирането чрез фасади може
                да огранични необходимото прекомпилиране при
                някоя малка промяна в някоя подсистема. Фасадата
                може да опрости пренасянето на системите към други
                платформи, защото е по-малко вероятно изграждането
                на една подсистема да изисква изграждането на
                всички останали.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Abstract Factory може да се използва заедно
                с Facade, за да предостави интерфейс за създаване на
                обекти на подсистемата по начин, независим от самата
                подсистема.<br>
                - Abstract Factory може да се използва като алтернатива
                на Facade за скриване на класове, специфични за
                конкретна платформа.<br>
                - Обикновенно има нужда само от един обект фасада.
                Затова фасадите често се реализират със Singleton.</h3>
        </div>
        <div class="box">
            <h2>FLYWEIGHT (МИНИОБЕКТ)</h2>
            <h3> <span>Цел:</span><br>
                Използва споделяне за ефективна поддръжка
                на голям брой малки обекти.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва, ако са налице всички
                изброени условия:<br>
                - Приложението използва голям брой обекти.<br>
                - Използва се много памет поради огромното количество
                обекти.<br>
                - По-голямата част от състоянието на обектите може да се
                направи външно.<br>
                - Много групи обекти могат да бъдат заменени от
                относително малко на брой споделени обекти, след като
                се премахне вътрешното им състояние.<br>
                - Приложението не зависи от идентичността на обектите.
                Тъй като миниобектите могат да бъдат споделяни,
                проверките за идентичност ще връщат истина за
                концептуално различни обекти.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Flyweight – декларира интерфейс, през който
                миниобектите могат да получават и въздействат върху
                външното си сътояние.<br>
                - ConcreteFlyweight – имплементира интерфейса на
                Flyweight и добавя променливи за вътрешното състояние,
                ако има такова. Един ConcreteFlyweight трябва да може да
                бъде споделян. Всяко съхранявано от него състояние
                трябва да бъде вътрешно, т.е. трябва да е независимо от
                контекста му.<br>
                - UnsharedConcreteFlyweight – не всички подкласове на
                Flyweight трябва да се споделят. Интерфейсът на
                Flyweight активира споделянето, но не го налага. <br>
                - FlyweightFactory<br>
                > създава и управлява миниобекти<br>
                > грижи се миниобектите да се споделят правилно. Когато някой
                клиент поиска даден миниобект, FlyweightFactory обектът
                предоставя съществуваща инстанция или създава нова, ако
                няма готова.<br>
                - Client<br>
                > поддържа връзки към миниобект / миниобекти<br>
                > изчислява или съхранява външното състояние на миниобект /
                миниобекти.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Състоянието, необходимо на даден миниобект за
                функционирането му, трябва да се характеризира
                или като вътрешно, или като външно. Вътрешното
                състояние се съхранява в ConcreteFlyweight обекта;
                външното състояние се съхранява или изчислява от
                Client обектите. Клиентите предават това състояние
                на миниобекта, когато извикват неговите операции.<br>
                - Клиентите не бива да инстанцират директно
                ConcreteFlyweight. Те трябва да се сдобиват с
                ConcreteFlyweight обекти единствено и само от
                FlyweightFactory, за да е сигурно, че те са споделени
                правилно.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Миниобектите могат да доведат до повишено
                натоварване в рън-тайма, свързано с пренос и
                откриване и/или изчисляване на външно състояние,
                особено ако преди това то е било съхранявано като
                вътрешно. Подобно натоварване се компенсира с
                икономия на пространство за съхранение, която
                нараства със споделяне на повече обекти.<br>
                - Икономията на пространство зависи от:<br>
                > Намаляването на общия брой инстанции вследствие на
                споделянето<br>
                > Количеството вътрешно състояние за всеки обект
                > Дали външното състояние се съхранява или изчислява.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Flyweight често се комбинира с шаблона
                Composition, за да се имплементира логическа
                йерархична структура чрез средствата на насочен
                ацикличен граф със споделени листа.<br>
                - Често е най-добре да имплементирате обектите,
                използвани в шаблоните State и Strategy, като
                миниобекти. </h3>
        </div>
        <div class="box">
            <h2>PROXY (ПЪЛНОМОЩНО)</h2>
            <h3> <span>Цел:</span><br>
                Предоставя заместител на друг обект, за да
                контролира достъпа до него.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Surrogate (Заместник, сурогат)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Шаблонът е приложим, когато има нужда от
                по-гъвкава или по-сложна връзка към някой обект, и
                обикновен указател не е достатъчен.<br>
                - Отдалеченото пълномощно (remote proxy) предоставя
                локален представител на обект от друго адресно
                пространство.<br>
                - Виртуалното пълномощно (virtual proxy) създава „тежки“
                обекти при поискване.<br>
                - Защитеното пълномощно (protection proxy) контролира
                достъпа до оргиналния обект. Защитните пълномощни са
                полезни, когато обектите трябва да имат различни права за
                достъп.<br>
                - Смарт референцията (Smart reference) е заместител на
                прост указател, извършваща допълнителни действия при
                осъществяване на достъп до обекта. Напр.:<br>
                > Брояч на референциите към истинския обект, така че той да
                може да бъде освободен автоматично, когато вече не е
                неоходим.<br>
                > Зареждане на постоянен обект в паметта при първото му
                използване.<br>
                > Проверка преди осъществяване на достъп, дали реалният
                обект не е заключен (за да се гарантира, че друг обект не може
                да го промени). </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Proxy<br>
                > Поддържа референция, даваща възможност на пълномощното да
                достига до реалния обект. Proxy може да поддържа референция
                към Subject, ако интерфейсите на RealSubject и Subject са еднакви.<br>
                > Предоставя интерфейс, идентичен на този на Subject, така че
                пълномощното да може да бъде заменено от реалния обект.<br>
                > Контролира достъпа до реалния обект и може да бъде отговорен
                за създаването и изтриването му.<br>
                > Другите задължения зависят от вида на пълномощното:<br>
                - Отдалечените пълномощни са отговорни за закодирането на дадена
                заявка и нейните аргументи и изпращането на кодираната заявка към
                истинския обект в друго адресно пространство.<br>
                - Виртуалните пълномощни може да кешират допълнителна
                информация относно реалния обект, за да могат да отложат
                осъществяването на достъп до него.<br>
                - Защитните пълномощни проверяват дали извикващият обект има
                подходящи разрешения за достъп, за да изпраща заявки.<br>
                - Subject – дефинира общия интерфейс за RealSubject и
                Proxy, така че Proxy да може да се използва навсякъде,
                където се очаква RealSubject.<br>
                - RealSubject – дефинира реалния обект, представляван от
                пълномощното </h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Когато е необходимо, Proxy препредава заявки към
                RealSubject в зависимост от вида на пълномощното.</h3>
            <h3> <span>СЛЕДСТВИЯ:</span><br>
                Шаблонът Proxy въвежда ниво на индирекция при
                достъпа до даден обект. Тя е с различни цели в
                зависимост от вида на пълномощното:<br>
                - Отдалеченото пълномощно може да скрие факта, че
                даден обект се намира в друго адресно пространство.<br>
                - Виртуалното пълномощно може да извърши
                оптимизации, напр. създаване на обект при поискване.<br>
                - Защитните пълномощни и смарт референциите дават
                възможност за извършване на допълнителни системни
                задачи при осъществяване на достъп до обектите.<br>
                - При създаването на обект при поискване може да се
                извърши още една оптимизация – нар. копиране при
                запис (copy-on-write). Копирането на обекти може да
                се редуцира. Ако обект рядко се променя, може да
                има брояч на референциите към обекта. Операциите
                за копиране на целевия обект само ще увеличават
                брояча на референциите. Само когато клиентът заяви
                операция за модифициране на обекта,
                пълномощното наистина ще направи копирането. В
                такъв случай пълномощното трябва да намали брояча
                на референциите на обекта. Когато броячът стане 0,
                обекта се изтрива.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Adapter предоставя различен интерфейс към обекта,
                който адаптира. Proxy предоставя същия интерфейс
                като обекта си. Но пълномощно, използвано за
                защита на достъпа, може да откаже да изпълни
                дадена операция, която самия обект бби изпълнил.<br>
                - Decorator може да имат имплементации подобни на
                Proxy, но те са с различна цел. Декораторът добавя
                едно или повече задължения към даден обект,
                докато пълномощното контролира достъпа до
                обекта. </h3>
        </div>
    </div>


    <!-- lekciq 6 -->

    <div class="lekciq lekciq6">
        <p class="heading">Лекция 6 - CHAIN OF RESPONSIBILITY, COMMAND, INTERPRETER, ITERATOR</p>
        <div class="box">
            <h2>BEHAVIORAL PATTERNS (ПОВЕДЕНЧЕСКИ ШАБЛОНИ)</h2>
            <h3>- Chain of Responsibility<br>
                - Command<br>
                - Interpreter<br>
                - Iterator<br>
                - Mediator<br>
                - Memento<br>
                - Observer<br>
                - State<br>
                - Strategy<br>
                - Template Method<br>
                - Visitor</h3>
        </div>
        <div class="box">
            <h2>CHAIN OF RESPONSIBILITY (ВЕРИГА ОТГОВОРНОСТИ)</h2>
            <h3> <span>Цел:</span><br>
                Избягва обвързването на изпращача на
                дадена заявка с получателя й, като дава
                възможност на няколко oбекта да обработят
                заявката. Свързва заедно приемащите обекти и
                предава заявката по веригата, докато някой от
                тях я обработи.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Повече от един обект могат да обработват дадена
                заявка, а изпълнителят не се знае предварително.
                Изпълнителят трябва да се установи автоматично.<br>
                - Искате да издадете заявка към един от няколко
                обекта, без да задавате изрично получателя.<br>
                - Множеството обекти, които могат да обработват
                дадена заяка, трябва да се задават динамично. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Handler<br>
                > дефинира интерфейс за обработка на заявки<br>
                > (незадължително) имплементира връзката към следващия
                елемент.<br>
                - ConcreteHandler<br>
                > обработва заявките, за които е отговорен<br>
                > може да достига следващия елемент<br>
                > ако ConcreteHandler може да обработи заявката, той го прави<br>
                в противен случай я предава на следващия елемент.<br>
                - Client<br>
                > инициира заявката към ConcreteHandler обект от веригата.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Когато даден клиент издаде заявка, тя се
                разпространява по веригата, докато някой
                ConcreteHandler обект поеме отговорност за
                обработката й.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Слабо обвързване. Шаблонът освобождава обектите
                от необходимостта да знаят кой друг обект обработва
                дадена заявка. Обектите трябва да знаят само, че
                заявката ще бъде обработена “правилно”. Както
                получателят, така и изпращачът нямат конкретни
                данни един за друг, а и обектите от веригата не е
                необходимо да знаят за нейната структура.
                Така шаблонът може да опрости взаимовръзките между
                обектите. Вместо те да поддържат референции към
                всички кандидат-получатели, те пазят една – единствена
                референция – към следващия елемент.<br>
                - Допълнителна гъвкавост при възлагането и
                разпределянето на отговорности на обекти. Може да
                добавяте или променяте отговорности за обработка на
                дадена заявка чрез добавяне към или промяна на
                веригата в рън-тайма. Може да комбинирате това със
                създаване на подкласове, за да определите статично
                изпълнителите.<br>
                - Обратната връзка не е сигурна. Тъй като заявката няма
                изричен получател, няма гаранция, че ще бъде
                обработена – заявката може да изпадне от края на
                веригата, без въобще да бъде обработена. Заявката
                може да остане необработена и ако веригата не е
                конфигурирана правилно. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                Шаблонът Chain of Responsibility често се прилага
                заедно с Composition. В този случай, родителят на
                компонента може да служи и за негов следващ
                елемент</h3>
        </div>
        <div class="box">
            <h2>COMMAND (КОМАНДА)</h2>
            <h3> <span>Цел:</span><br>
                Капсулира заявките във вид на обекти, така че
                клиентите да могат да се параметризират с различни
                заявки, да подреждат в опашки или да документират
                заявки, или да поддържат операции по отмяна на
                действие или възстановяването му.</h3>
            <h3> <span>Известен и като:</span><br>
                Action (Действие), Transaction (транзакция)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона, когато искате да:<br>
                - предавате действия за изпълнение като параметър на
                обектите<br>
                - задавате, подреждате в опашка и изпълнявате заявки по
                различно време. Един Command обект може да има
                продължителност на съществуване, независимо от
                първоначалната заявка<br>
                - поддържате отмяна на действия. Операцията Execute на
                Command може да съхранява състояния, за да има
                възможност за отмяна на действието на командата. Към
                интерфейса на Command трябва да се добави операция
                Unexecute, която да отменя действието на предишното
                извикване на Execute. Изпълнените команди се съхраняват в
                списък. Неограниченото отменяне и възстановяване се
                постига чрез обхождане на този списък напред и назад,
                извиквайки съответно Execute и Unexecute.<br>
                - поддържате дневник на промените, така че те да могат да
                се прилагат отново и отново при срив на системата. С
                разширяването на интерфейса на Command с операции за
                зареждане и съхраняване, можете да запазвате постоянен
                дневник на промените. Възстановяването от срив включва
                презареждане на съхранените команди и изпълнението им с
                операцията Execute<br>
                - стуктурирате дадена система около операции от високо
                ниво, изградени върху примитивни операции. Подобна
                структура е често срещана при информационните системи,
                поддържащи транзакции. Транзакцията капсулира набор от
                промени върху определени данни. Шаблонът Command
                предлага начин за моделиране на транзакциите. Командите
                са с общ интерфейс, давайки възможност да бъдат
                извиквани по един и същи начин. Шаблонът улеснява и
                разширяването на системата с нови транзакции.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Command – декларира интерфейс за изпълнение на
                операция.<br>
                - ConcreteCommand<br>
                > дефинира връзка между Receiver обект и действие<br>
                > имплементира Execute чрез извикване на съответните
                операции на Receiver.<br>
                - Client – създава ConcreteCommand обект и задава
                получателя му.<br>
                - Invoker – указва на командата да изпълни заявката.<br>
                - Receiver – знае как да извърши операциите, асоциирани с
                изпълнението на заявката. Всеки клас може да служи за
                Receiver (получател).</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентът създава ConcreteCommand обект и задава
                получателя му.<br>
                - Invoker обектът съхранява ConcreteCommand обекта.<br>
                - Invoker обектът издава заявка чрез извикване на
                Execute на командата. Когато командите са с
                възможност за отмяна, ConcreteCommand запазва
                информация, необходима за отмяната, преди да
                извика Execute.<br>
                - ConcreteCommand обектът извиква операция на своя
                получател, за да изпълни заявката.</h3>
            <h3> <span>СЛЕДСТВИЯ:</span><br>
                Шаблонът Command води до следното:
                - Класът Command разделя обекта, извикващ
                операцията, от този, който знае как да я извърши.<br>
                - Командите могат да бъдат манипулирани и
                разширявани както всеки друг обект.<br>
                - Можете лесно да сглобявате множество команди в поголеми сложни команди. По принцип, сложните
                команди са инстанции на шаблона Composition.<br>
                - Добавянето на нови команди е лесно, защото не се
                налага да променяте съществуващите класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Composition може да бъде използван за
                имплементирането на макрокоманди
                (MacroCommands).<br>
                - Шаблонът Memento може да запазва състоянието,
                необходимо на командата, за да отмени действието
                си.<br>
                - Команда, която трябва да бъде копирана, преди да
                бъде поставена в хронологичен дневник, действа
                като прототип.</h3>
        </div>
        <div class="box">
            <h2>ITERATOR (ИТЕРАТОР)</h2>
            <h3> <span>Цел:</span><br>
                Представя начин за последователен достъп до
                елементите на сложен обект, без да се разкрива
                същинското му представяне.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Cursor (Курсор)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Iterator:<br>
                - за да осъществявате достъп до съдържанието на
                структура от данни, бз да разкривате вътрешното му
                представяне<br>
                - за да поддържате множество обхождания на дадена
                структура от данни<br>
                - за да предоставяте унифициран интерфейс за
                обхождане на различни структури от данни.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Iterator – дефинира интерфейс за достигане и
                обхождане на елементите.<br>
                - ConcreteIterator<br>
                > имплментира интерфейса на Iterator<br>
                > следи текущата позиция при обхождането на структурата
                от данни.<br>
                - Aggregate – дефинира интерфейс за създаване на
                обект Iterator.<br>
                - ConcreteAggregate – имплементира интерфейса за
                създаване на Iterator, който връща инстанция на
                съответния клас ConcreteIterator.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                ConcreteIterator следи за текущия елемент от
                структурата от данни и може да изчислява
                следващия елемент от обхождането.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Шаблонът Iterator води до 3 важи следствия:<br>
                - Поддържа различни варианти за обхождане на дадена
                структура от данни. Структурите от данни могат да бъдат
                обхождани по много начини. За целта е необходимо да се
                смени инстанцията на итератора. Може да дефинирате
                подкласове на Iterator, за да поддърржате нови начини на
                обхождане.<br>
                - Итераторите опростяват интерфейса на Aggregate.<br>
                Интерфейсът за обхождане на Iterator елиминира нуждата от
                подобен интерфейс в Aggregate, опростявайки по този начин
                интерфейса на структурата от данни.<br>
                - В даден момент може да има повече от едно активно
                обхождане за дадена структура. Итераторът пази в себе си
                текущото състояние на обхождането. Поради това, в даден
                момент можете да извършвате повече от едно обхождане. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Итераторите често се прилагат върху рекурсивни
                структури като Composition.<br>
                - Шаблонът Memory често се използва заедно с
                шаблона Iterator. Iterator може да използва Memory,
                за да пази състоянието на итерацията във вътрешна
                променлива.</h3>
        </div>
    </div>


    <!-- lekciq 7 -->

    <div class="lekciq lekciq7">
        <p class="heading">Лекция 7 - MEDIATOR, MEMENTO, OBSERVER</p>
        <div class="box">
            <h2>BEHAVIORAL PATTERNS (ПОВЕДЕНЧЕСКИ ШАБЛОНИ)</h2>
            <h3>- Chain of Responsibility<br>
                - Command<br>
                - Interpreter<br>
                - Iterator<br>
                - Mediator<br>
                - Memento<br>
                - Observer<br>
                - State<br>
                - Strategy<br>
                - Template Method<br>
                - Visitor</h3>
        </div>
        <div class="box">
            <h2>MEDIATOR (ПОСРЕДНИК)</h2>
            <h3> <span>Цел:</span><br>
                Дефинира обект, капсулиращ
                взаимоотношенията между едно множество от
                обекти. Mediator съдейства за “разхлабване” на
                връзките, като не позволява на обектите да се
                обръщат изрично един към друг и дава възможност
                свободно да се променят взаимоотношенията им.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Множество обекти комуникират по добре
                дефинирани, но сложни начини. Резултатните
                взаимоотношения са неструктурирани и трудни за
                разбиране.
                - Многократното използване на даден обект е трудно,
                защото той има връзки и комуникира с много други
                обекти.
                - Едно поведение, разпределено между няколко
                класове, трябва да бъде настройвано и без
                създаване на много подкласове.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Mediator – дефинира интерфейс за комуникация с
                Colleague обекти.<br>
                - ConcreteMediator<br>
                > имплементира кооперативно поведение чрез координация на
                Colleague обекти<br>
                > знае и пази връзки към своите колеги.<br>
                - Colleague classes<br>
                > всеки клас Colleague знае своя Mediator обект<br>
                > всеки колега комуникира със своя посредник (mediator), когато
                е необходимо да комуникира с друг колега.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Колегите получават и изпращат заявки от Mediator
                обект. Посредникът имплементира кооперативното
                поведение като препраща заявките между
                съответните колеги.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Ограничава създаването на подкласове. Посредникът
                локализира поведение, което в друг случай би било
                разпределено в няколко обекта. Промяната на това поведение
                изисква създаването на подклас само на Mediator – класовете
                Colleague могат да бъдат използвани многократно, без промяна.<br>
                - Разделя колегите. Посредникът налага слаба връзка между
                колегите. Има възможност за промяна и многократно
                използване на класовете Colleague и Mediator независимо един
                от друг.<br>
                - Опростява обектните протоколи. Посредникът замества
                взаимовръзките от тип много-към-много с взаимовръзки от тип
                едно-към-много между посредника и неговите колеги.
                Взаимовръзките едно-към-много са по-лесни за разбиране,
                поддръжка и разширяване.<br>
                - Прави абстракция на това, как обектите си
                сътрудничат. Когато посредничеството е независима
                концепция и е капсулирано в обект, можете да се
                концентрирате въру това, как те си взаимодействат, а
                не върху индивидуалното им поведение.<br>
                - Централизира контрола. Шаблонът Mediator превръща
                сложността във взаимодействията в сложност на
                посредника. Тъй като посредника капсулира протоколи,
                той може да стане по-сложен от всеки отделен колега.
                Това, от своя стана, може да превърне посредника в
                труден за поддръжка.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Facade се различава от Mediator по това, че
                дава абстракция за подсистема от обекти, за да
                предостави по-удобен интерфейс. Неговият протокол е
                еднопосочен, т.е. Façade обектите правят заявки към
                класовете на подсистемите, но не и обратното. За
                разлика от него, Mediator дава възможност за
                кооперативно поведение, което обектите – колеги не
                предоставят или не могат да предоставят, и протоколът
                е двупосочен.<br>
                - Колегите могат да комуникират с посредника
                посредством шаблона Observer.</h3>
        </div>
        <div class="box">
            <h2>MEMENTO (СПОМЕН)</h2>
            <h3> <span>Цел:</span><br>
                Без да нарушава капсулирането, запазва
                вътрешното състояние на даден обект на външен
                носител, така че той да може да бъде възстановен в
                това състояние по-късно.</h3>
            <h3> <span>Известен и като:</span><br>
                Token (Жетон)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва когато са налице
                следните две условия:<br>
                - Трябва да се запише снимка на (цялото или част от)
                състоянието на обекта, така че той да може да бъде
                възстановен в това състояние на по-късен етап, и<br>
                - Директен интерфейс за получаване на състоянието
                би разкрил подробности от имплементацията и би
                нарушил капсулирането на обекта</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Memento<br>
                > Съхранява вътрешното състояние на обекта Originator.
                Споменът може да съхранява толкова информация, колкото
                е необходима по преценка на източника му.<br>
                > Предотвратява достъп на други обекти освен източника.
                Спомените на практика имат два интерфейса. Надзирателят
                вижда само един “тесен” интерфейс на Memento – той
                може единствено да предава спомени на други обекти.
                Създателят, от друга страна, вижда “широк” интерфейс,
                който му дава достъп до всички данни, необходими за
                възстановяването му в предишното състояние. В идеалния
                случай, само източникът, създал спомена, би имал право на
                достъп до вътрешното му състояние. <br>
                - Originator<br>
                > създава спомен, съдържащ снимка на текущото си вътрешно
                състояние<br>
                > използва спомена, за да възстанови вътрешното си състояние.
                - Caretaker<br>
                > отговорен е за съхранението на спомена<br>
                > никога не манипулира или изследва съдържанието на
                спомена.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Надзирателят поисква спомен от някой източник,
                задържа го известно време и го предава обратно на
                източника.<br>
                - Понякога надзирателят няма да предаде обратно
                спомена на източника, защото на него може никога
                да не му се наложи да се връща в предишно
                състояние.<br>
                - Спомените са пасивни. Само източникът, създал
                даден спомен, може да присвоява или извлича
                неговото състояние. </h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Използването на спомени може да е скъпо. Те може да
                доведат до значително натоварване, ако Originator
                трява да копира голямо количество информация, която
                да се съхранява в спомена, или ако клиентите създават
                и връщат спомени на източниците много често.<br>
                - Скрити разходи по поддръжката на спомени.
                Надзирателят е отговорен за изтриването на спомените,
                за които отговаря. Той обаче няма никаква представа
                колко данни има в спомена. Поради това, една
                тривиална имплементация на надзирателя може да
                доведе до много използвана памет за съхранение на
                спомените.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Command може да изполzват Memento, за да
                поддържат състояния за операции с възможност за
                отмяна.<br>
                - Ietrator – спомените могат да се изпозлват за
                обхождане.</h3>
        </div>
        <div class="box">
            <h2>OBSERVER (НАБЛЮДАТЕЛ)</h2>
            <h3> <span>Цел:</span><br>
                Дефинира зависимост от типа “едно към много”
                между обекти, така че когато един обект промени
                състоянието си, всички зависими от него обекти да
                бъдат уведомявани и обновявани автоматично.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Dependents (Зависимост), PublishSubscribe (Публикация - Абонамент).</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните ситуации:<br>
                - Когатоя някоя абстракция има 2 аспекта и единият
                зависи от другият. Капсулирането на тези аспекти в
                отделни обекти дава възможност те да бъдат
                променяни и използвани многократно независимо
                един от друг.<br>
                - Когато промяна в един обект изисква промяната и на
                други обекти и не знаете колко са те.<br>
                - Когато някой обект трябва да може да известява
                други обекти, без да прави предположения кои са те.
                С други думи – не искате тези обекти да са тясно
                свързани.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Subject<br>
                > знае наблюдателите си; произволен брой Observer обекти
                могат да наблюдават дадения обект<br>
                > предоставя интерфейс за закачане и откачане на Observer
                обекти.<br>
                - Observer – дефинира интерфейс за обновяване на обекти,
                които трябва да бъдат известявани за промени в даден
                наблюдаван обект.<br>
                - ConcreteSubject<br>
                > съхранява състояние, необходимо на ConcreteObserver обекти<br>
                > изпраща известие до своите наблюдатели, когато състоянието
                му се промени.<br>
                - ConcreteObserver<br>
                > поддържа връзка към ConcreteSubject обект<br>
                > съхранява състояние, което трябва да бъде съгласувано с това
                на наблюдавания обект<br>
                > имплементира интерфейса за обновяване на наблюдатели, за
                да запази състоянието си в съответствие с това на
                наблюдавания обект.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - ConcretSubject известява своите наблюдатели, когато
                настъпи промяна, която ще направи състоянието на
                наблюдателите му различно от неговото.<br>
                - След като бъде информиран за промяна в
                конкретния наблюдаван обект, ConcreteObserver
                обектът може да поиска от наблюдавания обект
                информация. ConcreteObserver използва тази
                информация, за да съгласува своето състояние с това
                на наблюдавания обект.</h3>
            <h3><span>ДИАГРАМА: СЪТРУДНИЧЕСТВО МЕЖДУ ЕДИН НАБЛЮДАВАН
                    ОБЕКТ И ДВА НАБЛЮДАТЕЛЯ</span><br>
                Забележка: Observer обектът, който изпраща заявката за промяна, отлага
                своето обновяване, докато не получи известие от наблюдавания обект. Notify
                може да се изивика не само от наблюдавания обект, а и от наблюдатели или
                от изцяло отделни обекти</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Шаблонът Observer дава възможност за независима
                промяна на наблюдаваните обекти и наблюдателите.
                Можете да използвате многократно наблюдаваните
                обекти, без да използвате техните наблюдатели, и
                обратното. Шаблонът дава възможност за добавяне на
                наблюдатели, без да се променя наблюдавания обект или
                другите наблюдатели.<br>
                - Абстрактна връзка между Subject и Observer. Всичко,
                което знае наблюдаваният обект е, че той има списък от
                наблюдатели, всеки от които следва простия интерфейс на
                абстрактния клас Observer. Наблюдаваният обект не знае
                конкретния клас на никой наблюдател. Поради това,
                връзката между наблюдаваните обекти и наблюдателите е
                абстрактна и минимална. <br>
                - Поддръжка на бродкаст комуникация. За разлика
                от обикновенната заявка, известието, изпращано от
                наблюдавания обект, не трябва да има изричен
                получател. Известието се изпраща автоматично до
                всички заинтересовани обекти, които са се
                абонирали за него. Наблюдаваният обект не се
                интересува колко заинтересувани обекти
                съществуват; единствената му отговорност е да ги
                извести. Това позволява свободно да добавяте и
                махате наблюдатели по всяко време. Наблюдателите
                сами решават дали ще обработят или ще игнорират
                известието.<br>
                - Неочаквани обновявания. Тъй като наблюдателите не
                знаят за съществуването на себеподобните си, те може
                да не знаят крайния ефект на една промяна на обекта.
                Една малка операция върху обекта може да причини
                лавина от обновявания в наблюдателите и зависимите от
                тях обекти. Недобре дефинирани или поддържани
                зависимости може да доведат до хаотични обновявания,
                които са трудни за проследяване.<br>
                Този проблем се утежнява допълнително и от факта, че простият
                протокол за обновяване не предоставя подробности за това,
                какво точно се е променило в наблюдавания обект. Без
                допълнителен протокол, който да помага на наблюдателите да
                открият какво се е променило, те може да са принудени да
                поработят здраво, за да извлекат промените. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Mediator: чрез капсулирането на сложна семантика
                на обновяване, Observer служи за посредник между
                обектите и наблюдателите.<br>
                - Observer може да изпозлва шаблона Singleton, за да
                бъде уникален и глобално достъпен.</h3>
        </div>
    </div>


    <!-- lekciq 8 -->

    <div class="lekciq lekciq8">
        <p class="heading">Лекция 8 - STATE, STRATEGY, TEMPLATE METHOD, VISITOR</p>
        <div class="box">
            <h2>BEHAVIORAL PATTERNS (ПОВЕДЕНЧЕСКИ ШАБЛОНИ)</h2>
            <h3>- Chain of Responsibility<br>
                - Command<br>
                - Interpreter<br>
                - Iterator<br>
                - Mediator<br>
                - Memento<br>
                - Observer<br>
                - State<br>
                - Strategy<br>
                - Template Method<br>
                - Visitor</h3>
        </div>
        <div class="box">
            <h2>STATE (СЪСТОЯНИЕ)</h2>
            <h3> <span>Цел:</span><br>
                Позволява на даден обект да променя
                поведението си, когато вътрешното му състояние се
                променя. Отвън ще изглежда, сякаш обектът се е
                превърнал в обект от друг клас.
            </h3>
            <h3><span>Известен и като:</span>
                Objects for States (Обекти за състояние).</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Ако поведението на даден обект зависи от състоянието
                му и той трябва да променя своето поведение в рънтайма, в зависимост от това състояние.<br>
                - Ако операциите имат големи условни оператори с
                много части, зависещи от състоянието на обекта. Това
                състояние обикновенно се представя чрез една или
                повече числови константи. В много случаи, няколко
                операции ще съдържат една и съща условна структура.
                Шаблонът State поставя всеки клон на условието в
                отделен клас. Това ви дава възможност да третирате
                състоянието на обекта като обект, който може да варира
                независимо от останалите обекти.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Context<br>
                > дефинира интерфейса, който представлява интерес за
                клиентите<br>
                > поддържа инстанция на подклас на State, дефинираща
                текущото състояние.<br>
                - State – дефинира интерфейс за капсулиране на
                поведението, асоциирано с определено състояние на
                Context.<br>
                - ConcreteState subclasses – всеки подклас имплементира
                поведение, свързано с едно състояние на Context</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Context делегира заявките, зависещи от състоянието
                му, на съответния обект ConcreteState.<br>
                - Контекстът може да предава себе си като аргумент на
                обекта State, обработващ заявката. Това дава
                възможност на обекта State да осъществява достъп
                до контекста, ако е необходимо.<br>
                - Context е основният интерфейс за клиентите. Те
                могат да конфигурират контекста чрез обекти State.
                След като даден контекст бъде конфигуриран,
                неговите клиенти не трябва да боравят директно с
                обектите State.<br>
                - Или Context, или подкласовете на ConcreteState,
                могат да вземат решение кое състояние след кое
                идва и при какви обстоятелства.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Шаблонът State води до следното:<br>
                - Локализира поведение, зависещо от едно състояние, и
                разделя поведението при различните състояния.
                Шаблонът поставя цялото поведение, свързано с
                определено състояние, в отделен обект. Тъй като целия код,
                зависещ от състоянието, се намира в подклас на State,
                лесно могат да се добавят нови състояния и
                преобразувания, като просто се дефинират нови
                подкласове.<br>
                - Обектите State могат да се споделят. Ако обектите State
                нямат член-променливи, т.е. представяното от тях
                състояние е закодирано изцяло от типа им – тогава
                контекстите могат да споделят един общ обект State. Когато
                състоянията се споделят по такъв начин, по същество те са
                миниобекти без вътрешно състояние, а само с поведение. <br>
                - Прави смяната на състоянията ясна. Когато един обект
                дефинира текущото си състояние само чрез стойностите
                на вътрешните си данни, смените на състоянията му
                нямат изрично представяне; те се проявяват само като
                присвоявания на някакви променливи. Въвеждането на
                отделни обекти за различните състояния прави
                преминаването между състоянията по-ясно.<br>
                Освен това, обектите State могат да защитават Context от
                нестабилни вътрешни състояния, защото смените на
                състоянията са атомарни от гледна точка на Context – те
                стават чрез смяна на стойността на една променлива
                (обектната променлива State на Context), а не на няколко.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Flyweight разглежда кога и как обектите
                State могат да се споделят. Обектите State често са
                Singleton.</h3>
        </div>
        <div class="box">
            <h2>STRATEGY (СТРАТЕГИЯ)</h2>
            <h3> <span>Цел:</span><br>
                Дефинира семейство алгоритми, капсулира всеки
                от тях и ги прави взаимозаменяеми. Стратегия дава
                възможност на алгоритмите да се променят независимо
                от клиентите, които ги използват</h3>
            <h3> <span>Известен и като:</span><br>
                Policy (Политика)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Много на брой свързани класове се различават само по
                поведението си. Стратегиите предоставят начин за
                конфигуриране на даден клас с едно от много
                поведения.<br>
                - Трябват ви различни варианти на един алгоритъм. Напр.
                можете да дефинирате алгоритми, съответстващи на
                различни изисквания за памет и скорост. Когато тези
                варианти се имплементират като йерархия от класове,
                може да изпозлвате стратегии.<br>
                - Някой алгоритъм използва данни, които не трябва да са
                известни на клиентите. Използвайте шаблона Strategy, за
                да избегнете разкриването на сложни, зависими от
                алгоритмите, структури от данни.<br>
                - Един клас дефинира много поведения и те се появяват
                под формата на множество условни оператори в
                неговите операции. Вместо множество условия,
                преместете съответните условни разклонения в техен
                собствен клас Strategy.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Strategy - декларира интерфейс, общ за всички
                поддържани алгоритми. Context използва този
                интерфейс, за да извика алгоритъма, дефиниран от
                ConcreteStrategy.<br>
                - ConcreteStrategy – имплементира алгоритъма
                посредством интерфейса на Strategy.<br>
                - Context<br>
                > конфигурира се чрез обект ConcreteStrategy<br>
                > пази референция към обект Strategy<br>
                > може да дефинира интерфейс, даващ възможност на Strategy
                да осъществява достъп до неговите данни</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Strategy и Context си взаимодействат, за да
                имплементират избрания алгоритъм. Контекстът може
                да предаде на стратегията всички необходими на
                алгоритъма данни при извикването му. Друга
                възможност е контекстът да предава себе си като
                аргумент на операциите на Strategy. Това дава
                възможност на стратегията при нужда да извиква
                обратно контекста.<br>
                - Контекстът препредава заявки от своите клиенти към
                своята стратегия. Клиентите обикновенно създават и
                предават на контекста обект ConcreteStrategy; от този
                момент нататък клиентите взаимодействат директно с
                контекста. Често клиентите могат да си избират от цяло
                семейство от класове ConcreteStrategy. </h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Семейства свързани алгоритми. Йерархиите от класове Strategy
                дефинират семейството от алгоритми, които да се използват
                многократно от контекстите. Наследяването може да помогне за
                изнасянето на общата функционалност на алгоритмите.<br>
                - Алтернатива на създаването на подкласове. Наследяването
                предоставя друг начин за поддръжка на разнообразие от алгоритми
                и поведения. Можете да създавате подкласове директно на класа
                Context, за да му добавите различни поведения. Това обаче
                закодира твърдо поведението в Context и смесва имплеметацията
                на алгоритмите с тази на Context, което прави Context по-труден за
                разбиране, поддръжка и разширяване. Освен това се елеминира
                възможността за динамична промяна на алгоритмите. Накрая се
                оказвате с множество свързани класове, разликите между които са
                единствено в алгоритмите или поведението, което предлагат.
                Капсулирането на алгоритмите в отделни калсове Strategy дава
                възможност за промяна на алгоритъма независимо от неговия
                контекст, което улеснява превключването, разбирането и
                разширяването на алгоритъма.<br>
                - Стратегиите елиминират условните оператори. Този шаблон
                предлага алтернатива на условните оператори за избор на
                желано поведение. Когато различните поведения бъдат
                струпани в един клас, е трудно да се избегнат условните
                конструкции при избора на правилното поведение.
                Капсулирането на поведението в отделни класове Strategy
                елиминира тези условни конструкции.<br>
                - Избор на имплеметации. Стратегиите могат да предоставят
                различни имплементации на едно и също поведение.
                Клиентът може да избира от различни стратегии с различни
                характеристики по отношение на памет и скорост.<br>
                - Клиентите трябва да знаят за различните стратегии.
                Недостатъкът на шаблона е в това, че клиентът трябва да знае
                по какво се различават отделничте класове Strategy, за да
                може да избере правилния. Може да се наложи клиентите да
                се занимават с въпроси от имплеметацията. Поради това,
                трябва да използвате шаблона Strategy само когато
                вариациите в поведението са свързани с клиентите, а не със
                стратегиите.<br>
                - Допълнителна комуникация между Strategy и Context.
                Интерфейсът на Stategy се споделя от всички класове
                ConcreteStrategy, незвисимо дали имплементираните от тях
                алгоритми са елементарни или сложни. Поради това има
                вероятност някои класове ConcreteStrategy да не използват
                цялата информация, предадена им през този интерфейс –
                простите класове ConcreteStrategy може дори въобще да не
                използват информацията! Т.е. може да има случаи, когато
                контекстът ще създава и инициализира параметри, които никога
                няма да се изпозлват. Ако това е проблем, ще трябва да
                обвържете по-тясно Strategy и Context.<br>
                - Увеличен брой обекти. Стратегиите увеличават броя на
                обектите в приложението. Понякога може да се намалят, като
                статегиите се имплементират във вид на обекти без състояния,
                които могат да се споделят от контекстите. Остатъчното
                състояние ще се поддържа от контекста, който го предава
                заедно с всяка заявка към обекта Strategy. Споделените
                стратегии не трябва да поддържат състояние между различните
                извиквания.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Flyweight: от обектите стратегии често се получават
                добри миниобекти. </h3>
        </div>
        <div class="box">
            <h2>TEMPLATE METHOD (ШАБЛОНЕН МЕТОД)</h2>
            <h3> <span>Цел:</span><br>
                дефнира скелета на алгоритъм в операция,
                оставяйки някои стъпки на подкласове. Позволява на
                подкласовете да предефинират определени стъпки от
                даден алгоритъм, без да се променя структурата му.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - За да имплементирате веднъж непроменливите части на
                даден алгоритъм и да оставите на подкласовете да
                имплементират поведението, което може да се променя.<br>
                - Когато общото поведение на подкласовете трябва да се
                отдели и локализира в общ клас, за да се избегне дублиране
                на код. Това е много добър пример за “реструктуриране с цел
                обобщаване”. Първо трябва да идентифицирате различията в
                съществуващия код и след това да ги отделите в нови
                операции. Накрая замествате различния код с шаблонен
                метод, който да извиква една от тези нови операции.<br>
                - За да контролирате разширяването на покласовете, можете
                да дефинирате шаблонен метод, извикващ “hook” операции
                в определени моменти, и така да разрешавате разширяване
                само на тези места.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - AbstractClass<br>
                > дефинира абстрактни примитивни операции, дефинирани
                от конкретни подкласове за имплементиране на даден
                алгоритъм<br>
                > имплементира шаблонен метод, дефиниращ скелета на
                определен алгоритъм. Шаблонният метод извиква
                примитивни операции, както и операции, дефинирани в
                AbstractClass или в други обекти.<br>
                - ConcreteClass<br>
                > имплементира примитивните операции за изпълнението на
                стъпки на алгоритъма, специфични за подкласовете</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                ConcreteClass разчита на AbstractClass да
                имплементира фиксираните стъпки на алгоритъма.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Шаблонните методи са основна техника за
                многократно използване на код. Те водят до
                инвертирана структура за управление, която понякога
                се нарича “принципът на Холивуд ” (т.е. “не ни се
                обаждайте, ние ще ви се обадим”). Това се отнася до
                начина, по който даден родителски клас извиква
                операциите на подкласовете си, а не обратното.<br>
                Шаблонните методи могат да извикват следните видове
                операции:<br>
                - конкретни операции (или върху ConcreteClass, или
                върху клиентските класове)<br>
                - конкретни операции върху AbstractClass (т.е. операции,
                които по принцип са полезни за подкласовете)<br>
                - примитивни операции (т.е. абстрактни операции)<br>
                - метод фабрика.<br>
                - hook операции, предоставящи подразбиращо се
                поведение, което подкласовете могат да разширят, ако
                е необходимо. Често hook операциите по
                подразбиране не правят нищо.<br>
                За шаблонните методи е важно да определят кои са hook
                операциите (могат да бъдат предефинирани) и кои са
                абстрактните операции (трябва да бъдат
                предефинирани). </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Factory Method често се извикват от шаблонни
                методи.<br>
                - Strategy: шаблонните методи използват наследяване,
                за да променят някоя част от алгоритъма.
                Стратегиите използват делигиране, за да променят
                целия алгоритъм.</h3>
        </div>
        <div class="box">
            <h2>VISITOR (ПОСЕТИТЕЛ)</h2>
            <h3> <span>Цел:</span><br>
                Представя операции, които се извършват върху
                елементите на обектна структура. Посетител дава
                възможност да се дефинира нова операция, без да се
                променят класовете на елементите, върху които работи
                тя.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Някоя структура от обекти съдържа много класове обекти с
                различни интерфейси и искате върху тези обекти да
                извършвате операции, зависещи от конкретния им клас.<br>
                - Много различни и несвързани операции трябва да се
                извършват над обектите от дадена структура и искате да
                избегнете натоварването на класовете им с тези операции.
                Шаблонът Посетител дава възможност тези операции да
                останат заедно, дефинирани в един клас. Когато структурата
                от обекти се споделя от много приложения, използвайте
                шаблона Посетител, за да поставите операциите само в
                онези приложения, които имат нужда от тях.<br>
                - Класовете, дефиниращи структурата от обекти, рядко се
                променят, но често искате да дефинирате нови операции
                върху структурата. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Visitor<br>
                > Декларира операция Visit за всеки клас ConcreteElement в
                структурата от обекти. Името и сигнатурата на операцията
                идентифицират класа, изпращаш заявката Visit до посетителя. Това
                дава възможност на посетителя да определи конкретния клас на
                посетения елемент. След това посетителят може да осъществи
                достъп до елемента директно през съответния интерфейс.<br>
                - ConcreteVisitor<br>
                > Имплементира всички операции, декларирани от Visitor. Всяка
                операция имплементира част от алгоритъм, дефинирана за
                съответния клас обекти в структурата. ConcreteVisitor предоставя
                контекста на алгоритъма и съхранява локалното му състояние. Това
                състояние често акумулира резултати по време на обхождане на
                структурата. <br>
                - Element - дефинира операция Accept, приемаща за аргумент
                някой посетител.<br>
                - ConcreteElement - имплементира операция Accept, приемаща
                за аргумент някой посетител.<br>
                - ObjectStructure<br>
                > може да изброи своите елементи<br>
                > може да предостави интерфейс от високо ниво, за да даде
                възможност на посетителя да посети неговите елементи<br>
                > може да бъде или Composite или Collection, например списък или
                множество.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиент, който използва шаблона Посетител, трябва
                да създаде ConcreteVisitor обект и след това да
                обходи структурата от обекти, посещавайки чрез
                посетителя всеки елемент.<br>
                - Когато даден елемент бъде посетен, той извиква
                операцията на Visitor, отговаряща за неговия клас.
                Елементът предоставя себе си като аргумент на тази
                операция, за да може посетителят да осъществи
                достъп до състоянието му, ако е необходимо.<br>
            </h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Шаблонът Посетител улеснява добавянето на нови
                операции. Посетителите улесняват добавянето на операции,
                зависещи от компонентите на сложни обекти. Можете да
                дефинирате нова операция за дадена структура от oбекти,
                като просто добавите нов посетител. В обратния случай – ако
                сте разпределили функционалността сред много класове, ще
                трябва да промените всеки един от тях, за да дефинирате
                новата операция.<br>
                - Посетителят събира накуп свързаните операции и разделя
                несвързаните. Свързаното поведение не се разпределя сред
                класовете, дефиниращи структурата от обекти – то се
                локализира в един посетител. Несвързаните поведения се
                разделят в собствени подкласове посетители. Това опростява
                едновременно и класовете, дефиниращи елементите, и
                алгоритмите, дефинирани в посетителите. Всички структури
                от данни, специфични за алгоритмите, могат да бъдат скрити
                в посетителя. <br>
                - Добавянето на нов клас ConcreteElement е трудно.
                Шаблонът Посетител затруднява добавянето на нови
                подкласове на Element. Всеки нов клас ConcreteElement
                води до нова абстрактна операция във Visitor и съответна
                имплементация във всеки клас ConcreteVisitor.<br>
                Основният фактор, определящ използването на шаблон
                Посетител, е дали е по-вероятно да промените алгоритъма,
                прилаган върху една структура от обекти, или класовете,
                изграждащи структурата. Йерархията от класове на Visitor
                може да бъде трудна за поддръжка, когато често се добавят
                нови класове ConcreteElement. В тези случаи може да е полесно да се дефинират операции в класовете,
                изграждаща
                структурата. Ако йерархията класове на Element е стабилна, но
                постоянно добавяте операции или променяте алгоритми,
                шаблонът Посетител ще ви помогне в управлението на
                промените.<br>
                - Посещения в различни йерархии от класове. Един
                итератор може да посети обектите в дадена структура,
                като ги обхожда чрез извикване на операциите им.
                Итераторът обаче не може да работи със структури с
                различни видове елементи.<br>
                - Акумулиране на състояние. Посетителите могат да пазят
                състоянието при посещаването на елементите от дадена
                структура от обекти. Без посетител, това състояние би
                било предавано като допълнителни аргументи на
                операциите, извършващи обхождането, или би било
                съхранявано в глобални променливи.<br>
                - Нарушаване на капсулирането. Подходът на шаблона
                Посетител предполага, че интерфейсът на ConcreteElement
                е достатъчно мощен, за да дава възможност на
                посетителите да вършат работата си. В резултат на това,
                шаблонът често ви принуждава да предоставяте публични
                операции, осъществяващи достъп до вътрешното
                състояние на обектите, което може да наруши
                капсулирането им. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Посетителите могат да бъдат използвани за
                прилагане на операции върху структура от обекти,
                дефинирана чрез шаблона Composition.<br>
                - Interpreter: Шаблонът Visitor може да се приложи за
                извършване на интерпретацията. </h3>
        </div>
    </div>
</body>