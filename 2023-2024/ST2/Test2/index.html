<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="style.css">
</head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode" />
<title>07.11.2023 Test 2</title>
<link rel="icon" href="icon.png" type="image/x-icon">

<body>
    <div class="search_box">
        <form action="" id="form2">
            <h1>Search</h1>
            <div class>
                <input type="text" id="search" class="textBox">
                <input type="button" id="submit_form" class="btn" onclick="checkInput()" value="Find next">
            </div>
        </form>
    </div>

    <script>
        function checkInput() {
            var query = document.getElementById('search').value;
            window.find(query);
            return true;
        }
    </script>

    <a class="go-to-btn" href="../Test1/index.html">Go To Test 1</a>
    <p class="heading2">Лекции 9-14</p>

    <!-- lekciq 9 -->

    <div class="lekciq lekciq9">
        <p class="heading">Лекция 9 - СОФТУЕРНИ АРХИТЕКТУРИ.
            АРХИТЕКТУРНИ СТИЛОВЕ И ШАБЛОНИ</p>
        <div class="box">
            <h2>1. СОФТУЕРНА АРХИТЕКТУРА</h2>
            <h3><span>Дефиниции:</span> <br>
                > Множество от артефакти (принципи, насоки,
                политики, модели, стандарти и процеси) и
                взаимоотношенията между тях, които насочват
                избора, създаването и осъществяването на
                софтуерни решения на зададени бизнес цели.
                > Включва описание на<br>
                - подсистеми и компоненти, представени със съответни
                функционални и нефункционални свойства...<br>
                - ...и взаимо-отношенията между тях в софтуерна
                система.<br>
                > Софтуерната архитектура не предлага конкретна
                реализация на софтуерна система, а задава
                рамка/дизайн (за нейната реализация).</h3>
            <h3><span>КОМПОНЕНТ НА СОФТУЕРНА СИСТЕМА:</span> <br>
                -> Компонентът е капсулирана част на софтуерна
                система. Притежава интерфейс, предоставящ начини
                за взаимодействие с него.<br>
                > Компонентите са изграждащи блокове (building
                blocks) на системата.<br>
                > На ниво език за моделиране компонентите може да
                се представят като процес, услуга и др.<br>
                > На ниво език за програмиране компонентите се
                реализират като модули, класове, обекти,
                множество от близки (в определена област)
                функции.</h3>
            <h3><span>ПОДСИСТЕМА</span> <br>
                > Подсистемата е съвкупност от компоненти,
                които съвместно реализират дадена задача.<br>
                > Подсистемата е отделен елемент в
                софтуерната архитектура.<br>
                > Тя реализира предназначената ѝ задача като
                взаимодейства с други подсистеми и
                компоненти.</h3>
            <h3><span>RATIONAL UNIFIED PROCESS</span> <br>
                Една архитектура е съвкупност от основополагащи
                решения относно:<br>
                > организацията на софтуерна система<br>
                > изборът на съставните й структурни елементи и
                техните интерфейси, включително:<br>
                - тяхното поведение (behavior) и взаимодействията
                помежду им (сътрудничества/collaborations)<br>
                - композицията на тези структурни и поведенчески
                елементи в прогресивно по-големи подсистеми<br>
                > архитектурният стил на организацията на
                софтуерната система, елементите ѝ, интерфейсите,
                взаимодействията и композицията им.</h3>
            <h3><span>GARLAN И SHAW</span> <br>
                ...отвъд алгоритмите и структурите от данни...<br>
                Архитектурата на софтуерна система включва:<br>
                > проектирането на структурата ѝ, и нейния контрол;<br>
                > протоколи за комуникация, синхронизация и достъп
                до данните;<br>
                > определяне на функционалността на проектираните
                елементи;<br>
                > физическото разпределение (на системата);<br>
                > съставът (композицията) на елементите;<br>
                > мащабиране и производителност;<br>
                > и избор между проектни алтернативи.</h3>
            <h3><span>SONI, NORD И HOFMEISTER (SIEMENS CORPORATE
                    RESEARCH)</span> <br>
                Софтуерната архитектура има най-малко четири различни
                изгледа. В рамките на всяка категория, структурите описват
                системата от различна гледна точка:<br>
                > Концептуална архитектура (conceptual architecture):
                описва системата от гледна точка на основните ѝ дизайн
                (съставни) елементи и връзките между тях.<br>
                > Архитектурата на модулна взаимо-свързаност (module
                interconnection architecture): включва две ортогонални
                структури: функционална декомпозиция и слоеве.<br>
                > Архитектурата на изпълнението (execution architecture):
                описва динамичната структура на системата.<br>
                > Архитектурата на кодa (code architecture): описва как
                изходния код, изпълнимия код и библиотеки са
                организирани в развойната среда.
            </h3>
            <h3><span>SHAW</span> <br>
                Изгледите на софтуерната архитектура:<br>
                > Структурни модели (Structural models)<br>
                > Модели на работни рамки (Framework models)<br>
                > Динамични модели (Dynamic models)<br>
                > Модели на процесите (Process models)</h3>
            <h3><span>SHAW: СТРУКТУРНИ МОДЕЛИ (STRUCTURAL MODELS)</span> <br>
                Структурните модели се състоят от компоненти,
                връзки между тях и други аспекти като:<br>
                > конфигурация, стил (configuration, style)<br>
                > ограничения, семантика (constraints, semantics)<br>
                > анализи, свойства (analyses, properties)<br>
                > обосновка, изисквания, потребностите на
                заинтересованите страни (rationale, requirements,
                stakeholders' needs).
            </h3>
            <h3><span>SHAW: РАМКОВИ МОДЕЛИ (FRAMEWORK MODELS)</span> <br>
                > Рамковите модели са подобни на структурните, но
                основната им насока е върху задаване на
                последователна структура за изграждане на цялата
                система, за разлика от определяне на съставните му
                елементите (при структурните).<br>
                > Рамкови модели често са насочени към определени
                области (домейни) или класове от проблеми.</h3>
            <h3><span>SHAW: ДИНАМИЧНИ МОДЕЛИ (DYNAMIC MODELS)</span> <br>
                Динамичните модели определят качествените
                промени в поведението на системите. „Динамично“
                може да се отнася до<br>
                > промени в конфигурация на системата;<br>
                > активиране или деактивиране на предварително
                определени комуникационни канали;<br>
                > или динамика в изчисленията, като например
                промяна на стойности на данни.</h3>
            <h3><span>SHAW: МОДЕЛИ НА ПРОЦЕСИТЕ (PROCESS
                    MODELS)</span> <br>
                > Моделите на процеси се фокусират върху
                - конструирането на архитектурата...
                - и стъпките или процеса, използвани в
                конструирането ѝ.
                > От тази гледна точка, архитектурата е
                резултат от следване на скрипт, управляващ
                процеса.</h3>
            <h3><span>ШАБЛОНИ ЗА ДИЗАЙН - КАТЕГОРИЗАЦИЯ</span> <br>
                - Създаващи шаблони (Creational patterns) са тези, които
                създават обекти. Това дава на програмата по-голяма
                гъвкавост при вземането на решения какви обекти трябва
                да бъдат създадени за всеки отделен случай.
                - Структурните шаблони (Structural patterns) помагат да се
                композират групи от обекти в по-големи и сложни
                структури, като например сложни потребителски
                интерфейси.
                - Поведенческите шаблони (Behavioral patterns) помагат да
                се определи комуникацията между обектите и контрола на
                потока в една комплексна система.</h3>
        </div>
        <div class="box">
            <h2>2. 1. АРХИТЕКТУРНИ СТИЛОВЕ – ARCHITECTURAL
                STYLES</h2>
            <h3><span>Дефиниции:</span> <br>
                > Архитектурният стил включва:<br>
                - описание на типа на компонентите и тяхната
                топология;<br>
                - описание на модела на данни и контрола на
                взаимодействието между компонентите;<br>
                - неформално описание на предимствата и
                недостатъците от използването на този стил.<br>
                > Архитектурните стилове са важни инженерни
                артефакти, защото дефинират класове от стандартни
                шаблони за разработка, заедно със свързаните с тях
                свойства.<br>
                > Те предлагат опит и доказателства за това, как се
                използва всеки клас.
            </h3>
            <h3><span>АРХИТЕКТУРНИ СТИЛОВЕ (2):</span> <br>
                > Архитектурният стил:<br>
                - осигурява абстрактна рамка за семейство
                (family) от системи;<br>
                - подобрява логическото и физическото
                разпределение (partitioning) на системите;<br>
                - насърчава повторна употреба на дизайна,
                като предоставя решения на често
                повтарящи се проблеми.
            </h3>
            <h3><span>2.2. АРХИТЕКТУРНИ ШАБЛОНИ – ARCHITECTURAL
                    PATTERN:</span> <br>
                > Един архитектурен шаблон описва общата
                организационна схема на структурата на
                софтуерни системи:<br>
                - предварително дефинирани подсистеми и
                техните отговорности;<br>
                - правила и насоки за организиране на
                подсистемите;<br>
                - отношенията между подсистеми.
            </h3>
            <h3><span>АРХИТЕКТУРНИ СТИЛОВЕ И АРХИТЕКТУРНИ ШАБЛОНИ</span> <br>
                > Архитектурните стилове, понякога се наричат
                архитектурни шаблони.<br>
                > Според други определения, архитектурният
                стил е композиция от шаблони, комбинирани
                с архитектурни принципи.<br>
                > Една софтуерна система може да включва
                няколко различни архитектурни стила и
                шаблона.
            </h3>
            <h3><span>2.3. FRAMEWORK (РАМКА)</span> <br>
                > Рамката е съвкупност от предположения, концепции и
                практики, които определят начин за представяне на
                дадена среда.<br>
                > Софтуерната рамка е частично реализирана
                софтуерна (под) система, която е предназначена да
                бъде инстанциирана (конфигурирана и стартирана).<br>
                - Тя определя архитектурата на съвкупност от (под)системи
                и предоставя основните градивни елементи за
                създаването им;<br>
                - Тя определя също и местата, които трябва да бъдат
                адаптирани (дописани) със специфична функционалност
            </h3>
            <h3><span>2.4. ОСНОВНИ АРХИТЕКТУРНИ ШАБЛОНИ</span> <br>
                > Три-слойна архитектура – Three-tier architecture<br>
                > Многослойна архитектура – Multilayered architecture<br>
                > Model-view-controller<br>
                > Микроядро – Microkernel<br>
                > Черна дъска – Blackboard pattern<br>
                > Sensor-controller-actuator<br>
                > Presentation–abstraction–control
            </h3>
            <h3><span>КАТЕГОРИИ АРХИТЕКТУРНИ СТИЛОВЕ</span> <br>
                > Структурни – Structure;<br>
                > Споделена (обща) памет – Shared memory;<br>
                > Съобщения – Messaging;<br>
                > Адаптивни системи – Adaptive systems;<br>
                > Разпределени системи – Distributed systems.<br>
                Някои от конкретните архитектурни стилове могат да
                се намират едновременно в няколко категории. Също
                така част от архитектурните шаблони могат да бъдат
                причислени към категории архитектурни стилове.
            </h3>
            <h3><span>СТРУКТУРНИ АРХИТЕКТУРНИ СТИЛОВЕ</span> <br>
                Определят вида и начина на организация на
                структурните елементи:<br>
                > Компонентно-базирана архитектура – Componentbased;<br>
                > Обектно-ориентирана архитектура – Object-Oriented;<br>
                > Монолитни приложения;<br>
                > Многослойни приложения;<br>
                > Комуникационни канали (канали за съобщения) и
                филтри – Pipes and filters.
            </h3>
            <h3><span>SHARED MEMORY АРХИТЕКТУРНИ СТИЛОВЕ</span> <br>
                > Центрирани върху данните – Data-centric;<br>
                > Черна дъска – Blackboard;<br>
                > Базирани на правила – Rule-based.
            </h3>
            <h3><span>АРХИТЕКТУРНИ СТИЛОВЕ ЗА СЪОБЩЕНИЯ</span> <br>
                > Базирани на събития – Event-driven;<br>
                > Публикуване-абонамент – Publish-subscribe;<br>
                > Асинхронни съобщения – Asynchronous
                messaging;<br>
                > Шина за съобщения – Message Bus.
            </h3>
            <h3><span>АРХИТЕКТУРНИ СТИЛОВЕ ЗА АДАПТИВНИ СИСТЕМИ</span> <br>
                > Plug-ins;<br>
                > Микроядро – Microkernel;<br>
                > Отражение – Reflection;<br>
                > Дизайн и езици, определени от предметната
                област – Domain specific languages and
                designs;
            </h3>
            <h3><span>АРХИТЕКТУРНИ СТИЛОВЕ ЗА РАЗПРЕДЕЛЕНИ СИСТЕМИ</span> <br>
                > Клиент-сървър – Client-server (включително 2-слойни,
                3-слойни, n-слойни);<br>
                > Споделяне на нищо (несподеляне) – Shared nothing
                architecture;<br>
                > Space-based architecture – GRID изчисления;<br>
                > Object request broker – ORB – среда за отдалечено
                извикване на процедури;<br>
                > Peer-to-peer (P2P) – равен с равен;<br>
                > Representational state transfer (REST);<br>
                > Архитектура ориентирана към услуги – Serviceoriented architecture (SOA);<br>
                > Облачни технологии – Cloud computing.
            </h3>
            <h3><span>2.5. РАЗГЛЕЖДАНЕ НА НЯКОИ АРХИТЕКТУРНИ
                    СТИЛОВЕ И ШАБЛОНИ</span> <br>
                1. Монолитни (еднослойни) приложения;<br>
                2. Клиент-сървър (двуслойни) архитектури;<br>
                3. Трислойни архитектури;<br>
                4. Многослойни архитектури;<br>
                5. Model-view-controller шаблон за дизайн;<br>
                6. Presentation–abstraction–control шаблон за
                дизайн.
            </h3>
            <h3><span>2.5.1. МОНОЛИТНИ (ЕДНОСЛОЙНИ) АРХИТЕКТУРИ</span> <br>
                > При монолитните приложения потребителския
                интерфейс и кодът за достъп до данните е
                комбиниран в една програма, която се изпълнява
                на една платформа.<br>
                > Характеристики:<br>
                - автономни – самостоятелни и независими от други
                приложения;<br>
                - няма модулност, позволяваща замяната на определена
                част с друга (без нужда от препрограмиране и
                прекомпилиране);<br>
                - използват се за по-елементарни десктоп приложения и
                приложения, изискващи по-голяма сигурност (и които не
                се нуждаят от мрежа за да достъпват някакви данни).
            </h3>
            <h3><span>2.5.2. КЛИЕНТ-СЪРВЪР АРХИТЕКТУРИ</span> <br>
                > Две отделни програми – клиент и сървър, създават общо
                приложение.<br>
                > Сървърът предоставя множество от услуги или/и
                функционалности за една или повече клиентски програми.<br>
                > Различни видове сървъри предоставят различни услуги:<br>
                - Уеб сървър<br>
                - Файлов сървър<br>
                - Сървър за бази от данни<br>
                - Пощенски сървър и др.<br>
                > Комуникацията между клиента и сървъра се осъществява
                върху<br>
                - транспортни протоколи – TCP/IP или др.<br>
                - приложни протоколи (в application нивото на транспортните
                протоколи) – HTTP, FTP, SMTP, TLS/SSL, SOAP, REST и мн.др.<br>
                - стандартизирани (или нестандартни) езици – SQL, JSON-, XMLбазирани и др.<br>
                - специализирани програмни абстракции и протоколи – soket-и, RPC
                (remote procedure call), RMI (remote method invocation), CORBA и др.
            </h3>
            <h3><span>ВИДОВЕ КЛИЕНТ-СЪРВЪР АРХИТЕКТУРИ</span> <br>
                > Тънък клиент (Thin client)<br>
                - основната работна логика се изпълнява на сървъра;<br>
                - клиента само представя резултатите;<br>
                - примери: уеб страници; уеб<br>
                > Дебел клиент (Fat client)<br>
                - сървъра се грижи основно за съхранение на данните<br>
                - работната логика се изпълнява в клиентското приложение<br>
                - обикновено има графичен интерфейс, който допълнително
                „утежнява“ приложението<br>
                - примери:<br>
                > десктоп и мобилни приложения<br>
                > други уеб приложения като Java аплети и java web start (бързо забравени
                технологии) , флаш приложения (нежелана технологии);<br>
                > При някои уеб приложения може да има клиентска логика
                реализирана чрез JavaScript – тогава клиентските страници не
                са дебели (не съдържат GUI-логика – тя се поддържа от
                браузъра), но не са и тънки (имат бизнес логика).
            </h3>
            <h3><span>ТРИСЛОЙНИ АРХИТЕКТУРИ (1)</span> <br>
                > При трислойните архитектури, логиката на приложението
                се разделя на три нива:<br>
                - Представително ниво (presentation tier) –
                потребителски интерфейс – уеб страници или форми с
                GUI;<br>
                - Приложно/логическо ниво (application/logic tier) –
                изпълнява основната логика на приложението; клиента
                предава заявките към междинното ниво, което се явява
                от своя страна клиент за нивото на данните, върху
                които извършва изискваната логика;<br>
                - Ниво за достъп до данните (data tier) – предоставя
                функционалност за работа с данните;
            </h3>
            <h3><span>ТРИСЛОЙНИ АРХИТЕКТУРИ (2)</span> <br>
                > Всяко от нивата отговаря само за определен вид
                функционалност и може да бъде разработвано от специалисти
                в съответната област (а не от един човек, разбиращ от всичко).<br>
                > Всяко от нивата комуникира единствено със съседните нива с
                цел сигурност. Данните са изолирани от потребителския
                интерфейс.<br>
                > Нивата може физически да са реализирани в една програма
                или в няколко отделни програми, в зависимост от конкретните
                приложения.<br>
                > При уеб приложенията има и други терминологии за нивата<br>
                - front-end – статично съдържание, предоставяно от уеб; използват се
                технологии като HTML, CSS, JavaScript (и по-рядко XML, XSLT и др.);<br>
                - middle-tier – динамична обработка и на съдържанието (PHP, Java,
                .Neт, Ruby, Python, Perl и др.) и генериране на статичното
                съдържание;<br>
                - back-end – създаване на БД и функционалност за работа с нея.
            </h3>
            <h3><span>ТРИСЛОЙНА АРХИТЕКТУРА ПРИ МОНОЛИТНИ И
                    КЛИЕНТ-СЪРВЪР ПРИЛОЖЕНИЯ</span> <br>
                > Отделни елементи от цялостното приложение също
                може да използват трислойна организация на
                функционалността
            </h3>
            <h3><span>ТРИСЛОЙНА АРХИТЕКТУРА ПРИ ТРИСЛОЙНИ И
                    МНОГОСЛОЙНИ ПРИЛОЖЕНИЯ</span> <br>
                > При трислойните и многослойните приложения трите
                функционални нива може да са физически разположени в
                различни части от архитектурата.
            </h3>
            <h3><span>2.5.4. МНОГОСЛОЙНИ АРХИТЕКТУРИ (1)</span> <br>
                Последно разгледаните 3 архитектури са многослойни.<br>
                > Многослойните архитектури също имат три основни
                слоя, свързани с представянето, основната логика и
                данните<br>
                > Някои от основните нива са хоризонтално разделени
                на под-нива<br>
                - Представително<br>
                > логика в представителното ниво;<br>
                > потребителски интерфейс;<br>
                - Ниво за данни<br>
                > ниво, отговарящо за съхранение на данните;<br>
                > ниво за достъп до данните – абстрактна логика за достъп
                до данните, предоставяща възможност за работа с
                различни СУБД по еднотипен начин
            </h3>
            <h3><span>МНОГОСЛОЙНИ АРХИТЕКТУРИ (2)</span> <br>
                > В основните нива може да има и независими един от друг
                или комуникиращи си (при необходимост) компоненти,
                които са с относително самостоятелна логика и
                функционалност:<br>
                > В нивото за данни може да има<br>
                - компонент за работа с БД;<br>
                - компонент за работа с услуги и др.<br>
                > В бизнес логиката може да има<br>
                - бизнес-компоненти, предоставящи базовата
                функционалност;<br>
                - модул за управление на компонентите и др.<br>
                > Съществуват и вертикални нива, предоставящи
                стандартна поддръжка на компонентите от
                хоризонталните нива:<br>
                - сигурност;<br>
                - комуникационни механизми;<br>
                - помощна функционалност.
            </h3>
            <h3><span>ЦЕЛИ НА МНОГОСЛОЙНИТЕ АРХИТЕКТУРИ</span> <br>
                > Многократно използване на кода (компонентите);<br>
                > Стабилност на кода – всеки компонент може да бъде
                подобрен при необходимост;<br>
                > Разделяне на отговорностите;<br>
                > Възможност за използване на множество машини;<br>
                > Използване на различни технологии;<br>
                > Възможност за скалиране на приложенията;<br>
                > Възможност за развитие – замяна на компоненти с
                по-подходящи.
            </h3>
            <h3><span>2.5.5. MODEL-VIEW-CONTROLLER ШАБЛОН ЗА
                    ДИЗАЙН</span> <br>
                > Model–view–controller
                (MVC) е софтуерен
                шаблон за дизайн;<br>
                > Използва се в десктоп,
                уеб и мобилните
                приложения;<br>
                > Разделя представянето
                на данните за
                потребителя от
                обработката им.
            </h3>
            <h3><span>КОМПОНЕНТИ НА MVC</span> <br>
                > Моделът определя поведението на приложението,
                задава бизнес логиката му и директно управлява
                данните.<br>
                > Изгледът представя информация за потребителя.
                Възможни са различни изгледи за едни и същи данни
                – текстове, графики и др.<br>
                > Контролерът обработва входните данни и ги
                превръща в команди за модела или изгледа.
            </h3>
            <h3><span>РАЗНОВИДНОСТИ НА MVC АРХИТЕКТУРАТА (1)</span> <br>
                > Model-View-Presenter<br>
                > Model-View-ViewModel
            </h3>
            <h3><span>РАЗНОВИДНОСТИ НА MVC АРХИТЕКТУРАТА (2)</span> <br>
                > В това представяне на MVC е указано, че вида на
                връзката между контролера и изгледа е 1:n – един
                контролер може да има много изгледи. Моделът
                обаче е само един.<br>
                > Възможно е изгледа при MVC да съдържа инстанция
                на модела или да не съдържа – втория случай е
                реализиран в следващия пример.<br>
                > Разликите в разновидностите на MVC архитектурата
                са в начина на организация на представянето на
                данните и бизнес логиката.
            </h3>
            <h3><span>ПРИМЕР НА JAVA: МОДЕЛ</span> <br>
                public class Model {<br>
                private int data;<br>
                public Model(){<br>
                data = 0;}<br>
                public Model(int data){<br>
                this.data = data;}<br>
                public void setData(int data){<br>
                this.data = data; }<br>
                public int getData(){<br>
                return data; } <br>}
            </h3>
            <h3><span>ПРИМЕР: VIEW</span> <br>
                public class View {<br>
                public View(){<br>
                }<br>
                public void show(int i){<br>
                System.out.println("Данни: " + i);
                }<br>
                }
            </h3>
            <h3><span>ПРИМЕР: CONTROLLER</span> <br>
                import java.util.Random;<br>
                public class Controller {<br>
                private Model model;<br>
                private View view;<br>
                public Controller(Model model, View view){<br>
                this.model = model;<br>
                this.view = view;
                }<br>
                // Промяна на модела - задаване на случайно число<br>
                // В реалните случаи данните се прочитат от форми, обработват се за грешки …<br>
                public void changeModel(){<br>
                Random r = new Random();<br>
                model.setData(r.nextInt());
                }<br>
                // Показване на данните във view-то<br>
                public void showView(){<br>
                view.show(model.getData());
                }<br>
                }
            </h3>
            <h3><span>ПРИМЕР: MVC ПРИЛОЖЕНИЕ</span> <br>
                public class MVCApplication { <br>
                public static void main(String []args){ <br>
                Model model = new Model(5); <br>
                View view = new View(); <br>
                Controller controller = new Controller(model, view); <br>
                // Входа минава единствено през контролера <br>
                controller.showView(); <br>
                controller.changeModel(); <br>
                controller.showView();
                } <br>
                } <br>
                Примерен резултат: <br>
                Данни: 5 <br>
                Данни: -10822813
            </h3>
            <h3><span>2.5.6. PRESENTATION–ABSTRACTION–CONTROL ШАБЛОН
                    ЗА ДИЗАЙН (HIERARCHICAL MODEL–VIEW–CONTROLLER)</span> <br>
                > PAC се използва в йерархични структури от агенти.<br>
                > Всеки агент е реализиран чрез MVC архитектурата
            </h3>
        </div>
    </div>


    <!-- lekciq 10 -->

    <div class="lekciq lekciq10">
        <p class="heading">Лекция 2 - Abstract Factory, Builder</p>
        <div class="box">
            <h2>CREATIONAL PATTERNS (ГРАДИВНИ ШАБЛОНИ)</h2>
            <h3>Abstract Factory<br>
                Builder<br>
                Factory Method<br>
                Prototype<br>
                Singleton</h3>
        </div>

        <div class="box">
            <h2>Abstract Factory (АБСТРАКТНА ФАБРИКА)</h2>
            <h3><span>Цел:</span> <br> Доставя интерфейс за създаване на
                семейства от свързани или зависими обекти, без
                да се специфицират техните конкретни класове.</h3>
            <h3><span>УПОТРЕБА: </span><br>
                Подходящо е да се използва в следните случаи: <br>
                - една система трябва да бъде независима от това, как
                се създават, композират и представят нейните
                продукти<br>
                - една система трябва да бъде конфигурирана с една
                от няколко групи продукти<br>
                - проектирано е група от свързани продукти да бъдат
                използвани заедно, и това ограничение трябва да се
                наложи стриктно<br>
                - искате да предоставите библиотеки от класове за
                продукти, като разкриете само техните интерфейси,
                без имплементацията им.</h3>
            <h3><span>СТРУКТУРА НА ШАБЛОНА: </span><br>
                - AbstractFactory - декларира интерфейс с методи за
                създаване на абстрактни продукти <br>
                - ConcreteFactory - имплементира операциите за
                създаване на конкретни продукти <br>
                - AbstractProduct - декларира интерфейс за клас
                продукти <br>
                - ConcreteProduct - дефинира продукт, който да бъде
                създаден от конкретна фабрика; имплементира
                интерфейса AbstractProduct <br>
                - Client - използва само интерфейси, декларирани чрез
                AbstractFactory и AbstractProduct класове.</h3>
            <h3><span>ВЗАИМОДЕЙСТВИЯ:</span> <br>
                - Обикновено в рънтайма се създава една единствена
                инстанция на класа ConcreteFactory. Тази конкретна
                фабрика създава продукти, които имат специфична
                имплементация. За да създадат различни групи
                продукти, клиентите трябва да използват различни
                конкретни фабрики. <br>
                - AbstractFactory отлага създаването на продукти, то се
                извършва от подкласа ConcreteFactory.</h3>
            <h3><span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span> <br>
                - Изолира конкретните класове. Една фабрика
                капсулира дейностите по създаване на продукти, и по
                този начин изолира клиентите от имплементацията
                на класовете. Клиентите манипулират инстанциите
                чрез техните абстрактни интерфейси. Имената на
                класовете на продуктите са изолирани в
                имплеметацията на конкретната фабриката; те не се
                появяват никъде в клиентския код. <br>
                - Лесна замяна на групи продукти. Класът на
                конкретна фабрика се появява само веднъж в кода на
                приложението - където се създава нейна инстанция.
                Това позволява лесна промяна на фабриката,
                съответно на цяла група продукти. Тъй като една
                абстрактна фабрика създава цяла група от продукти,
                цялата група продукти се променя наведнъж. <br>
                - Добавянето на нови видове продукти не е лесно.
                AbstractFactory интерфейса фиксира множество от
                продукти, които могат да бъдат създавани. Добавянето
                на нови видове продукти изисква разширяване на
                интерфейса AbstractFactory, което води след себе си до
                промяна на всички класове, които го наследяват. <br>
                - Налага съгласуваност между продукти. Когато е
                проектирано група продукти да работят заедно, е
                важно приложението да използва обектите от само
                една група в даден момент. AbstractFactory позволява
                лесно да се наложи това ограничение.</h3>
            <h3><span>ВРЪЗКА С ДРУГИ ШАБЛОНИ: </span> <br>
                - AbstractFactory класовете често се имплементират с
                Factory Method, може да се използва и Prototype. <br>
                - Конкретна фабрика често е удачно да се реализира с
                шаблона Singleton.</h3>
        </div>

        <div class="box">
            <h2>BUILDER (СТРОИТЕЛ)</h2>
            <h3><span>Цел:</span> <br>
                - Разделя процеса на създаването на сложен продукт
                от неговото представяне. <br>
                - Един и същи процес за създаване на продукт може
                да създаде продукт с различни представяния.</h3>
            <h3><span>УПОТРЕБА: </span><br>
                Подходящо е да се използва в следните случаи: <br>
                - алгоритъмът за създаване на сложен обект трябва да
                бъде независим от частите, от които е съставен
                обекта и начина, по който е асемблиран. <br>
                - процесът на конструиране трябва да позволи
                различни представяния на обекта.</h3>
            <h3><span>СТРУКТУРА НА ШАБЛОНА: </span><br>
                - Builder - абстрактен интерфейс за създаване на части от
                продукт <br>
                - ConcreteBuilder
                > конструира и асмеблира части на продукта чрез имплементиране
                на интерфейса Builder <br>
                > дефинира и следи за създаваните от него представяния <br>
                > предоставя интерфейс за извличане на продукта.<br>
                - Director - конструира обект, като използва интерфейса Builder <br>
                - Product<br>
                > представлява сложния обект, който се изгражда. ConcreteBuilder
                създава вътрешното представяне на продукта и дефинира
                процеса на неговото асемблиране <br>
                > включва класове, дефиниращи съставните части, включително
                интерфейсите за асемблиране на частите до крайния резултат.</h3>
            <h3><span>ВЗАИМОДЕЙСТВИЯ:</span> <br>
                - Клиентът създава обект Director и го конфигурира с
                желания Builder обект.
                - Director уведомява builder, когато трябва да се
                изгради някоя част от продукта.
                - Builder обработва заявките от director-а и добавя
                частите към продукта.
                - Клиентът извлича продукта от builder-а.</h3>
            <h3><span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span> <br>
                - Позволява да се променя вътрешното представяне
                на продукт. Обектът Builder доставя на director-а
                абстрактен интерфейс за изграждане на продукт.
                Интерфейсът позволява на builder-а да скрие
                представянето и вътрешната структурата на продукта.
                Той скрива и как е асемблиран продукта. Тъй като
                продуктът се конструира чрез абстрактен интерфейс,
                всичко, което трябва да се направи, за да се промени
                вътрешното представяне на продукта, е да се
                дефинира нов вид builder.<br>
                - Изолира кода за конструиране и представяне.
                Шаблонът Builder подобрява модулността чрез
                капсулиране на начина, по който се конструира и
                представя сложен обект. Клиентите не трябва да знаят
                нищо за класовете, които дефинират вътрешната
                структура на продукта (такива класове не са включени
                в интерфейса на Builder-а). <br>
                Всеки ConcreteBuilder съдържа всичкия код за
                създаване и асемблиране на конкретен вид продукт.
                Кодът е написан веднъж; след това различни Director
                обекти могат да го използват многократно, за да
                изградят различни варианти на продукта от един и
                същи набор от части.<br>
                - Има силен контрол върху процеса на изграждане
                на обект. За разлика от градивните паблони, които
                изграждат продукти “наведнъж”, шаблонът Builder
                конструира продукт стъпка по стъпка под контрола
                на director-а. Чак след като продуктът е завършен,
                director го взема от builder-а. По този начин
                интерфейса Builder рефлектира върху процеса на
                конструиране на продукта повече отколкото другите
                градивни шаблони. Това дава по-прецизен контрол
                върху процеса на изграждане и следователно на
                вътрешната структура на изграждания продукт.
            </h3>
            <h3><span>ВРЪЗКА С ДРУГИ ШАБЛОНИ: </span> <br>
                - Abstract Factory прилича на Builder по това, че
                също може да изгради сложни обекти. Основната
                разлика е, че шаблона Builder е фокусиран върху
                изграждане на сложен обект стъпка по стъпка.
                Акцента на Abstract Factory е върху групи от
                продукти (прости или сложни). Builder връща
                продуктa като крайна стъпка, за разлика от
                шаблона Abstract Factory, където продукта се
                връща веднага. <br>
                - Често обекта, изграден от Builder е Composite.</h3>
        </div>
    </div>


    <!-- lekciq 11 -->

    <div class="lekciq lekciq11">
        <p class="heading">Лекция 3 - FACTORY METHOD, PROTOTYPE, SINGLETON</p>
        <div class="box">
            <h2>CREATIONAL PATTERNS (ГРАДИВНИ ШАБЛОНИ)</h2>
            <h3>Abstract Factory<br>
                Builder<br>
                Factory Method<br>
                Prototype<br>
                Singleton</h3>
        </div>
        <div class="box">
            <h2>FACTORY METHOD (МЕТОД ФАБРИКА)</h2>
            <h3> <span>Цел:</span><br>
                Дефинира интерфейс за създаване на обект, но
                позволява на подкласовете да решат кой клас да
                инстанцират. Factory Method позволява на един клас
                да отложи инстанцирането за подкласовете.</h3>
            <h3> <span>Известен и като:</span><br>
                Virtual Constructor (Виртуален конструктор)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - един клас не може да предвиди класа на обектите,
                които трябва да създаде<br>
                - един клас иска неговите подкласове да определят
                обектите, които той създава<br>
                - класове делегират отговорност на един от няколко
                помощни подкласа, и искате да локализирате
                знанието кой е конкретния подклас. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Product - дефинира интерфейса на обектите,
                създавани от метода фабрика.<br>
                - ConcreteProduct – имплементира интерфейса
                Product.<br>
                - Creator<br>
                > декларира метода фабрика, който връща обект от тип
                Product. Creator може също да дефинира
                имплементация по подразбиране на метода фабрика,
                който връща ConcreteProduct обект по подразбиране<br>
                > може да извика метода фабрика, за да създаде обект Product.<br>
                - ConcreteCreator<br>
                > предефинира метода фабрика, така, че да върне
                инстанция на съответния ConcreteProduct</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Creator разчита на неговите подкласове да
                дефинират метода фабрика така, че той да може да
                върне инстанция на съответния ConcreteProduct.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Методите фабрики елиминират необходимостта от
                използване на специфични за приложенията класове във
                вашия код. В кода се използва само интерфейса Product,
                следователно може да работи със всички дефинирани от
                потребителите ConcreteProduct класове.<br>
                - Предоставя точки за закачане за подкласове.
                Създаването на обекти в клас с метод-фабрика винаги е
                по-гъвкаво, отколкото директно създаване на обект.
                Методът фабрика дава на подкласовете възможност за
                предоставяне на разширена версия на даден обект.<br>
                - Свързва паралелни йерархии от класове. В
                разгледания пример метода фабрика се извиква само от
                Creators. Но в общия случай клиентите могат да
                извлекат полза в случаи на паралелни йерархии от
                класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Abstract Factory често се имплементира чрез Factory
                Methods.<br>
                - Factory Methods обикновено се извикват от
                шаблонни методи (Template Methods).<br>
                - Prototypes не изискват да се създават подкласове на
                Creator. Въпреки това, те често изискват операция
                Initialize в класа Product. Creator използва Initialize да
                инициализира обекта. Factory Method не изисква
                такава операция.</h3>
        </div>
        <div class="box">
            <h2>PROTOTYPE (ПРОТОТИП)</h2>
            <h3> <span>Цел:</span><br>
                Специфицира вида на обектите, които създава,
                с помощта на прототипна инстанция, и създава нови
                обекти чрез копиране на този прототип.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Prototype, когато една система трябва
                да е независима от това как се създават, композират и
                представят нейните продукти, и освен това:<br>
                - когато класовете, които трябва да се инстанцират, се
                специфицират в рън-тайма (напр. при динамично
                зареждане), или<br>
                - за да избегнете изграждането на йерархия от класове
                фабрики, която да е паралелна на йерархия от класове
                продукти, или<br>
                - когато инстанциите на един клас може да имат едно от
                няколко различни състояния. В този случай може да е поудобно да инсталирате съответния брой прототипи и
                да ги
                клонирате, вместо да инстанциирате класа ръчно всеки път
                в съответното състояние. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Prototype - декларира интерфейс за клонирането си.<br>
                - ConcretePrototype – имплементира операция за
                клонирането си.<br>
                - Client - създава нов обект, като кара прототипа да се
                клонира.<br>
                Основната отговорност на шаблона Prototype е всеки подклас
                на Prototype да имплементира операцията Clone.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиент иска даден прототип да се клонира.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Prototype има много от предимствата на Abstract Factory
                и Builder: скрива конкретните класове на продукта от
                клиента, като по този начин намалява броят на
                имената, които клиентите знаят. Тези шаблони
                позволяват на клиента да работи със спефични за
                приложенията класове, без да е необходима промяна.<br>
                - Добавяне и премахване на продукти в рън-тайма.
                Прототипите позволяват включване на нов
                конкретен клас продукти в една система просто чрез
                регистриране на прототипна инстанция в клиента.
                Това е малко по-гъвкаво от другите градивни
                шаблони, защото клиента може да инсталира и
                премахва прототипи в рън-тайма.<br>
                - Специфициране на нови обекти чрез промяна на
                стойностите. Силно динамичните системи позволяват
                дефиниране на ново поведение посредством композиране
                на обекти, напр. чрез специфициране на стойности за
                променливите на даден обект (вместо чрез дефиниране на
                нови класове). Може ефективно да се дефинират нови
                видове обекти чрез инстанцииране на съществуващи
                класове и регистриране на инстанциите като прототипи на
                обекти на клиента. Всеки клиент може да покаже ново
                поведение като делегира отговорността на прототипа.<br>
                Този вид дизайн позволява на потребителите да дефинират
                нови "класове" без програмиране. В действителност,
                клонирането на прототип е подобно на инстанциране на клас.
                Шаблонът Prototype може значително да редуцура броя на
                класовете, от които се нуждае приложението.<br>
                - Специфициране на нови обекти чрез промяна на
                структурата. За целта е необходимо само да се
                добави нов обект като прототип.<br>
                - Редуциране на подкласовете. Factory Method
                често произвежда йерархия на Creator класове,
                която е паралелна на йерархията от класове
                продукти. Шаблонът за дизайн Prototype позволява
                да се клонира prototype вместо да искате някой
                factory method да направи нов обект. Т.е. не е
                необходима йерархия от Creator класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Prototype и Abstract Factory са конкурентни шаблони
                в някои отношения, но те могат да се използват и
                заедно. Abstract Factory може да съхранява
                множество от прототипи, от които да клонира и
                връща обекти продукти.<br>
                - Дизайни, които използват интензивно шаблони за
                дизайн Composite и Decorator, често могат да
                извлекат полза от Prototype.</h3>
        </div>
        <div class="box">
            <h2>SINGLETON (СЕК)</h2>
            <h3> <span>Цел:</span><br>
                Осигурява клас, който е проектиран да има
                само една инстанция, и предоставя глобална точка за
                достъп до нея.</h3>
            <h3> <span>МОТИВАЦИЯ:</span><br>
                - За някои класове е важно да имат точно една
                инстанция.<br>
                - Напр. в една система може да има много принтери,
                но трябва да има само един мениджър на принтери.<br>
                - Възможно е да използва клас, който сам да е
                отговорен за следенето на единствената си
                инстанция. Класът може да гарантира, че не може да
                се създаде друга инстанция (чрез прехващане на
                заявки за създаване на нови инстанции) и да
                предостави начин за достъп до инстанцията.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Singleton в следните случаи:<br>
                - трябва да има точно една инстанция на клас, и тя
                трябва да е достъпна за клиентите чрез известна
                точка за достъп<br>
                - когато единствената инстанция трябва да бъде
                разширяема чрез създаване на подкласове и
                клиентите трябва да могат да използват
                разширените инстанции, без да променят техния
                първоначален код. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Singleton
                > дефинира операция Instance, която позволява на клиентите
                достъп до уникалната инстанция;
                > може да бъде отговорен за създаването на своята уникална
                инстанция.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиентите достъпват инстанцията на Singleton само чрез операция Instance.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Контролиран достъп до единствената инстанция. Тъй
                като класът Singleton капсулира единствената си
                инстанция, той може да има строг контрол върху това как
                и кога клиентите имат достъп до нея.<br>
                - Редуциране на name space. Шаблонът Singleton е
                подобрение спрямо глобалните променливи. Той избягва
                "натоварването" на name space с глобални променливи,
                които съхраняват единични инстанции.<br>
                - Позволява усъвършенстване на операциите и
                представянето. Класът Singleton може да бъде
                наследяван от други класове, и е лесно да се
                конфигурира приложение с инстанция на този разширен
                клас. Може да конфигурирате приложението с
                инстанцията на необходимия ви клас в рън-тайма.<br>
                - Позволява променлив брой инстанции. Възможно
                е да се разреши създаването на повече от една
                инстанция на класа Singleton. Може да се използва
                същия подход за контрол на броя на инстанциите.
                За целта е необходимо да се промени само
                операцията, която предоставя достъп до
                инстанцията на Singleton.<br>
                - Повече гъвкавост, отколкото операциите на клас.
                Друг начин за пакетиране на функционалностите на
                singleton е да се използват операции на клас. Но в
                този случай е трудно да се промени дизайна да се
                даде възможност за повече от една инстанция на
                клас.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                Много шаблони за дизайн могат да бъдат
                имплементирани с помощта на шаблона Singleton.
                Напр. Abstract Factory, Builder и Prototype.</h3>
        </div>
    </div>


    <!-- lekciq 12 -->

    <div class="lekciq lekciq12">
        <p class="heading">Лекция 4 - ADAPTER, BRIDGE, COMPOSITE</p>
        <div class="box">
            <h2>STRUCTURAL PATTERNS (СТРУКТУРНИ ШАБЛОНИ)</h2>
            <h3>- Adapter<br>
                - Bridge<br>
                - Composite<br>
                - Decorator<br>
                - Facade<br>
                - Flyweight<br>
                - Proxy</h3>
        </div>
        <div class="box">
            <h2>ADAPTER (АДАПТЕР)</h2>
            <h3> <span>Цел:</span><br>
                Преобразува интерфейса на даден клас в
                друг интерфейс, какъвто клиента очаква.<br>
                - Позволява на класове да работят заедно в
                случаите, в които е невъзможно поради
                несъвместими интерфейси.</h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Необходимо е да се използва съществуващ клас, но
                интерфейсът му не отговаря на това, което е
                необходимо<br>
                - Трябва да създадете клас с възможност за многократно
                използване, който да работи с несвързани или
                непредвидими класове (т.е. с класове, с които може да
                има несъвместими интерфейси) </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Target – дефинира конкретният интерфейс, използван от
                Client<br>
                - Client – работи с обекти, отговарящи на интерфейса на
                Target<br>
                - Adaptee – дефинира съществуващ интерфейс, нуждаещ
                се от адаптиране<br>
                - Adapter – адаптира интерфейса на Adaptee към
                интерфейса на Target.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентите извикват операции на инстанция на
                Adapter.<br>
                - Адаптерът от своя страна извиква операции на
                Adaptee, които изпълняват заявката.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Адаптира адаптирания към целевия клас, като създава
                конкретен клас адаптер. Адаптерът на класове няма да
                работи, ако искате да адаптирате даден клас и всички
                негови подкласове.<br>
                - Дава възможност на адаптера да предефинира част от
                поведението на адаптирания клас, тъй като Adapter е
                подклас на Adaptee.<br>
                - Въвежда само един обект и не е необходимо
                допълнително ниво на индирекция, за да се достигне до
                адаптирания обект.<br>
                - Какво може да адаптира Adapter? Адаптерите се
                различават по количеството работа, която
                извършват, за да адаптират Adaptee към интерфейса
                на Target. Това може да включва от проста смяна на
                имената на някои операции до поддържането на
                изцяло различен набор от операции.<br>
                - Включваеми адаптери. Вграждането на
                адаптирането на интерфейси в класа дава
                възможност за включване на класа в съществуващи
                системи, които може да очакват разлчини
                интерфейси към този клас.<br>
                - Използване на двупосочни адаптери за постигане на
                прозрачност. Един проблем е това, че адаптерите не са
                прозрачни за всички клиенти. Адаптираният обект
                вече не отговаря на интерфейса на Adaptee, така, че не
                може да се използва навсякъде вместо него.<br>
                Двупосочните адаптери (two-way adapters) могат да
                предоставят подобна прозрачност. Те са особено
                полезни, когато два различни клиента трябва да
                виждат един обект по различен начин.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Bridge е със структура, подобна на адаптер на обект,
                но с друга цел. Неговото предназначение е да отдели
                интерфейса от неговата имплементация, така че те
                да могат да се променят независимо и лесно. За
                разлика от него, Adapter има за цел да промени
                интерфейса на съществуващ обект.<br>
                - Decorator разширява друг обект, без да променя
                интерфейса му. Той е по-прозрачен за приложението,
                в сравнение с Adapter. Decorator поддържа
                рекурсивно композиране, което не е възможно при
                чистите адаптери.<br>
                - Proxy дефинира инстанция или заместител да друг
                обект, и не променя интерфейса му.</h3>
        </div>
        <div class="box">
            <h2>BRIDGE (МОСТ)</h2>
            <h3> <span>Цел:</span><br>
                Разделя абстракция от нейната имплементация,
                така че двете да могат да се променят независимо.</h3>
            <h3> <span>Известен и като:</span><br>
                Handle/Body (Манипулатор/Тяло)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да избегнете твърдо обвързване между
                дадена абстракция и нейната имплементация (напр.
                когато имплементацията трябва да се избира или
                сменя в рън-тайма).<br>
                - Както абстракциите, така и техните имплементации
                трябва да бъдат разширяеми чрез създаване на
                подкласове. В този случай шаблонът Bridge дава
                възможност за комбиниране на различни абстракции
                и имплементации и независимото им разширяване.<br>
                - Промените в имплементацията на дадена абстракция
                не трябва да влияят върху клиентите (т.е. да не се
                налага прекомпилиране на техния код).</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Abstraction:<br>
                > Дефинира интерфейса на абстракцията<br>
                > Поддържа референция към обект от тип Implementor.<br>
                - RefinedAbstraction – разширява интерфейса, дефиниран от
                Abstraction.<br>
                - Implementor – дефинира интерфейса на класовете на
                имплементацията. Този интерфейс не е задължително да
                отговаря напълно на интерфейса на Abstraction (двата
                интерфейса могат да са доста различни). Обикновенно
                интерфейсът на Implementor предоставя само елементарни
                операции, а Abstraction дефинира операции от по-високо
                ниво, базирайки се на тези елементарни операции.<br>
                - ConcreteImplementor – дефинира конкретна имплементация
                на implementor.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Abstraction препредава заявките от клиентите към
                своя обект Implementor.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Разделяне на интерфейса и имплементацията.
                Имплементацията не е обвързана твърдо с даден
                интерфейс. Тя може да бъде конфигурирана в рън-тайма,
                възможно е даже обект да смени своята имплементация в
                рън-тайма.<br>
                Разделянето на Abstraction и Implementor елиминира и
                зависимостите от имплементацията по време на
                изпълнението. Промяната на имплементациония клас не
                изисква прекомпилиране на класа Abstraction и неговите
                клиенти.<br>
                Едно такова разделяне улеснява използването на слоеве,
                съответно по-добро структуриране на системата. Частта на
                най-високо ниво в системата трябва да знае само за
                Abstraction и Implementor.<br>
                - Подобрена разширяемост. Йерархиите Abstraction и
                Implementor може да се разширяват независимо една от
                друга.<br>
                - Скриване на подробностите на имплементацията от
                клиентите. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Abstract Factory може да се създаде и конфигурира с
                конкретен Bridge.<br>
                - Шаблонът Adapter се използва, когато несвързани
                класове трябва да работят заедно. Bridge се използва
                предварително при проектирането, за да могат
                абстракциите и имплементациите да се променят
                независимо едни от други. </h3>
        </div>
        <div class="box">
            <h2>COMPOSITE (КОМПОЗИЦИЯ)</h2>
            <h3> <span>Цел:</span><br>
                Композиране на обекти в дървовидни структури
                за представяне на йерархии от елементи.<br>
                - Шаблонът дава възможност на клиентите да третират
                по един и същи начин отделни обекти и композиции
                от обекти.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да представите йерархии от съставни обекти<br>
                - Искате клиентите да могат да игнорират разликите
                между композиции от обекти и отделни обекти.
                Клиентите ще третират еднакво всички обекти в
                сложната структура.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Component<br> Декларира интерфейса на обектите в композицията<br>
                > Имплементира частите от интерфейса, общи за всички класове<br>
                > Декларира интерфейс за достъп и управление на вложени
                компоненти (наследници)<br>
                > (незадължително) дефинира интерфейс за достъп до родителя на
                даден компонент в рекурсивната структура и го имплементира, ако
                се налага.<br>
                - Leaf<br>
                > Представлява обекти листа в композицията (листата нямат
                наследници)<br>
                > Дефинира поведение за примитивните обекти в композицията.<br>
                - Composite<br>
                > дефинира поведение за компоненти с наследници<br>
                > съхранява наследници<br>
                > имплементира операции, свързани с наследници, в
                интерфейса на Component.<br>
                - Client<br>
                > манипулира обекти от композицията чрез интерфейса на
                Component.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Клиентите използват интерейса на класа Component,
                за да взаимодействат с обекти от композицията. Ако
                обектът е листо, заявката се обработва направо. Ако
                обектът е композиция, тя обикновенно се предава
                към компонентите наследници, евентуално
                извършвайки допълнителни операции преди и/или
                след предаването.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Дефинира класове йерархии, състоящи се от
                примитивни и сложни обекти. Примитивните обекти
                могат да бъдат композирани в по-сложни обекти, които
                от своя страна могат да бъдат композирани рекурсивно
                и т.н. Там, където кода на клиента очаква примитивен
                обект, може да приеме и композиран.<br>
                - Опростява клиента. Клиентите могат да третират
                еднакво композициите и отделните обекти. Клиентите
                обикновенно не знаят дали си имат работа с листо или
                с композиция. Това опростява клиентския код, защото
                се избягват проверки за типа на обектите от
                композицията.<br>
                - Улеснява добавянето на нови видове компоненти.
                Новодефинираните подкласове на Composite или Leaf
                работят автоматично със съществуващите структури и
                клиентски код. Не се налага промяна на клиентите за
                нови класове Component.<br>
                - Може да се направи дизайна прекалено общ.
                Улесненото добавяне на нови компоненти води до
                проблем – трудно е да се ограничат компонентите на
                композицията. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Често връзката компонент – родител се използва за шаблона
                Chain of Responcibility.<br>
                - Шаблонът Decorator често се използва с шаблона Composition.
                Когато се използват декоратори и композитори, обикновенно те
                имат общ родителски клас. Това означава, че декораторите ще
                трябва да поддържат иинтерфейса на компонента с операции
                като Add, Remove, GetChild и т.н.<br>
                - Flyweight дава възможност за поделяне на компоненти, но те
                вече няма да имат връзка към родителите си.<br>
                - Iterator може да се използва за обхождане на композиции.<br>
                - Visitor локализира операциите и поведението, което иначе би
                било разпръснато из сложните и примитивните класове на
                композицията.</h3>
        </div>
    </div>


    <!-- lekciq 13 -->

    <div class="lekciq lekciq13">
        <p class="heading">Лекция 5 - DECORATOR, FACADE, FLYWEIGHT, PROXY</p>
        <div class="box">
            <h2>STRUCTURAL PATTERNS (СТРУКТУРНИ ШАБЛОНИ)</h2>
            <h3>- Adapter<br>
                - Bridge<br>
                - Composite<br>
                - Decorator<br>
                - Facade<br>
                - Flyweight<br>
                - Proxy</h3>
        </div>
        <div class="box">
            <h2>DECORATOR (ДЕКОРАТОР)</h2>
            <h3> <span>Цел:</span><br>
                Динамично възлагане на допълнителни
                отговорности на даден обект. Декораторите предоставят
                гъвкава алтернатива на създаването на подкласове при
                разширяване на функционалността.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - За динамично и прозрачно добавяне на
                отговорности към отделни обекти, т.е. без да се
                засягат целевите обекти.<br>
                - За отговорности, които могат да се отнемат.<br>
                - Когато разширяването чрез създаване на подкласове
                не е практично. Понякога е възможен голям брой
                независими разширения и това води до експозиция
                на подклалсове, които трябва да поддържат всяка
                възможна комбинация. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Component – дефинира интерфейс за обекти, към
                които могат да се добавят динамично отговорности.<br>
                - ConcreteComponent – дефинира обект, към който
                могат да се добавят допълнителни отговорности.<br>
                - Decorator – поддържа референция към обект
                Component и дефинира интерфейс, отговарящ на
                интерфейса на Component.<br>
                - ConcreteDecorator – добавя характеристики към
                компонента.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Decorator предава заявки към своя обект Component.
                Има възможност за извършване на допълнителни
                операции преди и след предаването на заявката.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Предлага по-голяма гъвкавост от статичното
                наследяване. Предоставя по-гъвкав начин за добавяне
                на отговорности към обекти в сравнение със
                статичното (множествено) наследяване. При
                декораторите, отговорности могат да се добавят и
                махат в рън-тайма просто чрез закачането и откачането
                им. За разлика от това, наследяването изисква
                създаване на нов клас за всяка нова отговорност. Това
                води до възникване на много класове и увеличава
                сложността на системата.<br>
                - Избягва претоварването на класовете в йерархията с
                разнообразни възможности. Шаблонът предлага подход
                за добавяне на отговорности в движение. Вместо да
                поддържате всички предвидими възможности в един
                сложен клас с възможности за настройка, той дава
                възможност да дефинирате един прост клас и постепенно
                да добавяте функционалност чрез декоратори.
                Функционалността може да се композира от прости
                малки части. Създаването на нови видове декоратори е
                лесно, независимо от класовете на обектите, които
                разширяват.<br>
                - Декораторът и неговият компонент не са идентични.
                Декораторът служи като прозрачна опаковка. От гледна
                точка на идентичността на обекта, един декориран
                компонент не е идентичен със самия компонент.<br>
                - Множество малки обекти. Използването на шаблона
                Decorator често води до системи, композирани от
                множество малки обекти, които си приличат. Обектите
                се различават само по начина, по който са
                взаимосвързани, а не по типа си. Такива системи може
                да са трудни за разучаване и дебъгване</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Decorator се различава по Adapter по това, че
                адаптерът само променя задълженията на обекта, а
                не неговия интерфейс; адаптерът дава на обекта
                съвсем нов интерфейс.<br>
                - Decorator може да се разглежда като изродена
                композиция (Composition) със само един компонент.
                Декораторът обаче добавя нови задължения – той не
                е предназначен за агрегация на обекти.<br>
                - Decorator дава възможност за промяна на външността
                на даден обект; Strategy дава възможност за промяна
                на външността му. Това са два алтернативни начина
                за промяна на един обект.</h3>
        </div>
        <div class="box">
            <h2>FACADE (ФАСАДА)
            </h2>
            <h3> <span>Цел:</span><br>
                Предоставя унифициран интерфейс към набор
                интерфейси в една подсистема. Шаблонът дефинира
                интерфейс от високо ниво, който прави подсистемата
                лесна за използване.</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Искате да предоставите прост интерфейс към една
                сложна система. Подсистемите стават все по-сложни при
                своята еволюция. Използването на повечето шаблони за
                дизайн води до повече и по-малки класове. Това прави
                системата по-удобна за многократна употреба и полесна за настройка, но тя става по-трудна за използване
                от клиентите, които нямат нужда от разширениете
                възможности за настройка. Фасадата може да
                предостави прост, подразбиращ се изглед към
                подсистемата, който е достатъчен за повечето
                подклиенти. Само клиентите, имащи нужда от повече
                възможности за настройка, ще трябва да поглеждат
                отвъд фасадата.<br>
                - Има много зависимости между клиентите и
                класовете на имплементацията на една абстракция.
                Като въведете фасада, за да разделите подсистемата
                от клиентите и от другите подсистеми, ще подобрите
                независимостта и преносимостта й.<br>
                - Искате да изградите своите подсистеми на слоеве.
                Използвайте фасада, за да дефинирате входна точка
                към всяко ниво на подсистемата. Ако подсистемите
                са зависими една от друга, можете да опростите
                зависимостите, като ги накарате да комуникират
                помежу си единствено чрез своите фасади.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Facade<br>
                > знае кои класове на подсистемата отговарят за дадена заявка<br>
                > делегира клиентските заявки към съответните обекти на
                подсистемата.<br>
                - Класове на подсистемата<br>
                > имплементират функционалността на подсистемата<br>
                > извършват работа, зададена от обекта фасада<br>
                > не знаят нищо за фасадата, т.е. не пазят референции към нея.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентите комуникрат с подистемата, като изпращат
                заявки към фасадата, която ги предава към съответния
                обект/обекти от подсистемата. Обектите от
                подсистемата извършват същинската работа, но може
                да е наложи самата фасада да свърши малко работа по
                преобразуване на своя интерфейс към интерфейсите на
                подсистемата.<br>
                - Клиентите, използващи фасадата, нямат директен
                достъп до обектите на подсистемата.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Държи настрана клиентите от компонентите на
                подсистемата. По този начин се намалява броя на
                обектите, с които работи клиента и се улеснява
                използването на подсистемата.<br>
                - Не пречи на приложенията да използват класовете на
                подсистемата, ако им се налага. Така има възможност
                за избор между лесно използване и богати
                възможности.<br>
                - Постига се слабо обвързване между подсистемата и
                нейните клиенти. Това позволява промяна на
                компонентите на подсистемата, без да се засягат
                нейните клиенти. Фасадите могат да елиминират
                сложните и цикличните зависимости. Намаляването на
                зависимостите при компилирането чрез фасади може
                да огранични необходимото прекомпилиране при
                някоя малка промяна в някоя подсистема. Фасадата
                може да опрости пренасянето на системите към други
                платформи, защото е по-малко вероятно изграждането
                на една подсистема да изисква изграждането на
                всички останали.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Abstract Factory може да се използва заедно
                с Facade, за да предостави интерфейс за създаване на
                обекти на подсистемата по начин, независим от самата
                подсистема.<br>
                - Abstract Factory може да се използва като алтернатива
                на Facade за скриване на класове, специфични за
                конкретна платформа.<br>
                - Обикновенно има нужда само от един обект фасада.
                Затова фасадите често се реализират със Singleton.</h3>
        </div>
        <div class="box">
            <h2>FLYWEIGHT (МИНИОБЕКТ)</h2>
            <h3> <span>Цел:</span><br>
                Използва споделяне за ефективна поддръжка
                на голям брой малки обекти.
            </h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва, ако са налице всички
                изброени условия:<br>
                - Приложението използва голям брой обекти.<br>
                - Използва се много памет поради огромното количество
                обекти.<br>
                - По-голямата част от състоянието на обектите може да се
                направи външно.<br>
                - Много групи обекти могат да бъдат заменени от
                относително малко на брой споделени обекти, след като
                се премахне вътрешното им състояние.<br>
                - Приложението не зависи от идентичността на обектите.
                Тъй като миниобектите могат да бъдат споделяни,
                проверките за идентичност ще връщат истина за
                концептуално различни обекти.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Flyweight – декларира интерфейс, през който
                миниобектите могат да получават и въздействат върху
                външното си сътояние.<br>
                - ConcreteFlyweight – имплементира интерфейса на
                Flyweight и добавя променливи за вътрешното състояние,
                ако има такова. Един ConcreteFlyweight трябва да може да
                бъде споделян. Всяко съхранявано от него състояние
                трябва да бъде вътрешно, т.е. трябва да е независимо от
                контекста му.<br>
                - UnsharedConcreteFlyweight – не всички подкласове на
                Flyweight трябва да се споделят. Интерфейсът на
                Flyweight активира споделянето, но не го налага. <br>
                - FlyweightFactory<br>
                > създава и управлява миниобекти<br>
                > грижи се миниобектите да се споделят правилно. Когато някой
                клиент поиска даден миниобект, FlyweightFactory обектът
                предоставя съществуваща инстанция или създава нова, ако
                няма готова.<br>
                - Client<br>
                > поддържа връзки към миниобект / миниобекти<br>
                > изчислява или съхранява външното състояние на миниобект /
                миниобекти.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Състоянието, необходимо на даден миниобект за
                функционирането му, трябва да се характеризира
                или като вътрешно, или като външно. Вътрешното
                състояние се съхранява в ConcreteFlyweight обекта;
                външното състояние се съхранява или изчислява от
                Client обектите. Клиентите предават това състояние
                на миниобекта, когато извикват неговите операции.<br>
                - Клиентите не бива да инстанцират директно
                ConcreteFlyweight. Те трябва да се сдобиват с
                ConcreteFlyweight обекти единствено и само от
                FlyweightFactory, за да е сигурно, че те са споделени
                правилно.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Миниобектите могат да доведат до повишено
                натоварване в рън-тайма, свързано с пренос и
                откриване и/или изчисляване на външно състояние,
                особено ако преди това то е било съхранявано като
                вътрешно. Подобно натоварване се компенсира с
                икономия на пространство за съхранение, която
                нараства със споделяне на повече обекти.<br>
                - Икономията на пространство зависи от:<br>
                > Намаляването на общия брой инстанции вследствие на
                споделянето<br>
                > Количеството вътрешно състояние за всеки обект
                > Дали външното състояние се съхранява или изчислява.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Flyweight често се комбинира с шаблона
                Composition, за да се имплементира логическа
                йерархична структура чрез средствата на насочен
                ацикличен граф със споделени листа.<br>
                - Често е най-добре да имплементирате обектите,
                използвани в шаблоните State и Strategy, като
                миниобекти. </h3>
        </div>
        <div class="box">
            <h2>PROXY (ПЪЛНОМОЩНО)</h2>
            <h3> <span>Цел:</span><br>
                Предоставя заместител на друг обект, за да
                контролира достъпа до него.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Surrogate (Заместник, сурогат)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Шаблонът е приложим, когато има нужда от
                по-гъвкава или по-сложна връзка към някой обект, и
                обикновен указател не е достатъчен.<br>
                - Отдалеченото пълномощно (remote proxy) предоставя
                локален представител на обект от друго адресно
                пространство.<br>
                - Виртуалното пълномощно (virtual proxy) създава „тежки“
                обекти при поискване.<br>
                - Защитеното пълномощно (protection proxy) контролира
                достъпа до оргиналния обект. Защитните пълномощни са
                полезни, когато обектите трябва да имат различни права за
                достъп.<br>
                - Смарт референцията (Smart reference) е заместител на
                прост указател, извършваща допълнителни действия при
                осъществяване на достъп до обекта. Напр.:<br>
                > Брояч на референциите към истинския обект, така че той да
                може да бъде освободен автоматично, когато вече не е
                неоходим.<br>
                > Зареждане на постоянен обект в паметта при първото му
                използване.<br>
                > Проверка преди осъществяване на достъп, дали реалният
                обект не е заключен (за да се гарантира, че друг обект не може
                да го промени). </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Proxy<br>
                > Поддържа референция, даваща възможност на пълномощното да
                достига до реалния обект. Proxy може да поддържа референция
                към Subject, ако интерфейсите на RealSubject и Subject са еднакви.<br>
                > Предоставя интерфейс, идентичен на този на Subject, така че
                пълномощното да може да бъде заменено от реалния обект.<br>
                > Контролира достъпа до реалния обект и може да бъде отговорен
                за създаването и изтриването му.<br>
                > Другите задължения зависят от вида на пълномощното:<br>
                - Отдалечените пълномощни са отговорни за закодирането на дадена
                заявка и нейните аргументи и изпращането на кодираната заявка към
                истинския обект в друго адресно пространство.<br>
                - Виртуалните пълномощни може да кешират допълнителна
                информация относно реалния обект, за да могат да отложат
                осъществяването на достъп до него.<br>
                - Защитните пълномощни проверяват дали извикващият обект има
                подходящи разрешения за достъп, за да изпраща заявки.<br>
                - Subject – дефинира общия интерфейс за RealSubject и
                Proxy, така че Proxy да може да се използва навсякъде,
                където се очаква RealSubject.<br>
                - RealSubject – дефинира реалния обект, представляван от
                пълномощното </h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Когато е необходимо, Proxy препредава заявки към
                RealSubject в зависимост от вида на пълномощното.</h3>
            <h3> <span>СЛЕДСТВИЯ:</span><br>
                Шаблонът Proxy въвежда ниво на индирекция при
                достъпа до даден обект. Тя е с различни цели в
                зависимост от вида на пълномощното:<br>
                - Отдалеченото пълномощно може да скрие факта, че
                даден обект се намира в друго адресно пространство.<br>
                - Виртуалното пълномощно може да извърши
                оптимизации, напр. създаване на обект при поискване.<br>
                - Защитните пълномощни и смарт референциите дават
                възможност за извършване на допълнителни системни
                задачи при осъществяване на достъп до обектите.<br>
                - При създаването на обект при поискване може да се
                извърши още една оптимизация – нар. копиране при
                запис (copy-on-write). Копирането на обекти може да
                се редуцира. Ако обект рядко се променя, може да
                има брояч на референциите към обекта. Операциите
                за копиране на целевия обект само ще увеличават
                брояча на референциите. Само когато клиентът заяви
                операция за модифициране на обекта,
                пълномощното наистина ще направи копирането. В
                такъв случай пълномощното трябва да намали брояча
                на референциите на обекта. Когато броячът стане 0,
                обекта се изтрива.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Adapter предоставя различен интерфейс към обекта,
                който адаптира. Proxy предоставя същия интерфейс
                като обекта си. Но пълномощно, използвано за
                защита на достъпа, може да откаже да изпълни
                дадена операция, която самия обект бби изпълнил.<br>
                - Decorator може да имат имплементации подобни на
                Proxy, но те са с различна цел. Декораторът добавя
                едно или повече задължения към даден обект,
                докато пълномощното контролира достъпа до
                обекта. </h3>
        </div>
    </div>


    <!-- lekciq 14 -->

    <div class="lekciq lekciq14">
        <p class="heading">Лекция 6 - CHAIN OF RESPONSIBILITY, COMMAND, INTERPRETER, ITERATOR</p>
        <div class="box">
            <h2>BEHAVIORAL PATTERNS (ПОВЕДЕНЧЕСКИ ШАБЛОНИ)</h2>
            <h3>- Chain of Responsibility<br>
                - Command<br>
                - Interpreter<br>
                - Iterator<br>
                - Mediator<br>
                - Memento<br>
                - Observer<br>
                - State<br>
                - Strategy<br>
                - Template Method<br>
                - Visitor</h3>
        </div>
        <div class="box">
            <h2>CHAIN OF RESPONSIBILITY (ВЕРИГА ОТГОВОРНОСТИ)</h2>
            <h3> <span>Цел:</span><br>
                Избягва обвързването на изпращача на
                дадена заявка с получателя й, като дава
                възможност на няколко oбекта да обработят
                заявката. Свързва заедно приемащите обекти и
                предава заявката по веригата, докато някой от
                тях я обработи.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Wrapper (Обвивка)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Подходящо е да се използва в следните случаи:<br>
                - Повече от един обект могат да обработват дадена
                заявка, а изпълнителят не се знае предварително.
                Изпълнителят трябва да се установи автоматично.<br>
                - Искате да издадете заявка към един от няколко
                обекта, без да задавате изрично получателя.<br>
                - Множеството обекти, които могат да обработват
                дадена заяка, трябва да се задават динамично. </h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Handler<br>
                > дефинира интерфейс за обработка на заявки<br>
                > (незадължително) имплементира връзката към следващия
                елемент.<br>
                - ConcreteHandler<br>
                > обработва заявките, за които е отговорен<br>
                > може да достига следващия елемент<br>
                > ако ConcreteHandler може да обработи заявката, той го прави<br>
                в противен случай я предава на следващия елемент.<br>
                - Client<br>
                > инициира заявката към ConcreteHandler обект от веригата.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                Когато даден клиент издаде заявка, тя се
                разпространява по веригата, докато някой
                ConcreteHandler обект поеме отговорност за
                обработката й.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                - Слабо обвързване. Шаблонът освобождава обектите
                от необходимостта да знаят кой друг обект обработва
                дадена заявка. Обектите трябва да знаят само, че
                заявката ще бъде обработена “правилно”. Както
                получателят, така и изпращачът нямат конкретни
                данни един за друг, а и обектите от веригата не е
                необходимо да знаят за нейната структура.
                Така шаблонът може да опрости взаимовръзките между
                обектите. Вместо те да поддържат референции към
                всички кандидат-получатели, те пазят една – единствена
                референция – към следващия елемент.<br>
                - Допълнителна гъвкавост при възлагането и
                разпределянето на отговорности на обекти. Може да
                добавяте или променяте отговорности за обработка на
                дадена заявка чрез добавяне към или промяна на
                веригата в рън-тайма. Може да комбинирате това със
                създаване на подкласове, за да определите статично
                изпълнителите.<br>
                - Обратната връзка не е сигурна. Тъй като заявката няма
                изричен получател, няма гаранция, че ще бъде
                обработена – заявката може да изпадне от края на
                веригата, без въобще да бъде обработена. Заявката
                може да остане необработена и ако веригата не е
                конфигурирана правилно. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                Шаблонът Chain of Responsibility често се прилага
                заедно с Composition. В този случай, родителят на
                компонента може да служи и за негов следващ
                елемент</h3>
        </div>
        <div class="box">
            <h2>COMMAND (КОМАНДА)</h2>
            <h3> <span>Цел:</span><br>
                Капсулира заявките във вид на обекти, така че
                клиентите да могат да се параметризират с различни
                заявки, да подреждат в опашки или да документират
                заявки, или да поддържат операции по отмяна на
                действие или възстановяването му.</h3>
            <h3> <span>Известен и като:</span><br>
                Action (Действие), Transaction (транзакция)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона, когато искате да:<br>
                - предавате действия за изпълнение като параметър на
                обектите<br>
                - задавате, подреждате в опашка и изпълнявате заявки по
                различно време. Един Command обект може да има
                продължителност на съществуване, независимо от
                първоначалната заявка<br>
                - поддържате отмяна на действия. Операцията Execute на
                Command може да съхранява състояния, за да има
                възможност за отмяна на действието на командата. Към
                интерфейса на Command трябва да се добави операция
                Unexecute, която да отменя действието на предишното
                извикване на Execute. Изпълнените команди се съхраняват в
                списък. Неограниченото отменяне и възстановяване се
                постига чрез обхождане на този списък напред и назад,
                извиквайки съответно Execute и Unexecute.<br>
                - поддържате дневник на промените, така че те да могат да
                се прилагат отново и отново при срив на системата. С
                разширяването на интерфейса на Command с операции за
                зареждане и съхраняване, можете да запазвате постоянен
                дневник на промените. Възстановяването от срив включва
                презареждане на съхранените команди и изпълнението им с
                операцията Execute<br>
                - стуктурирате дадена система около операции от високо
                ниво, изградени върху примитивни операции. Подобна
                структура е често срещана при информационните системи,
                поддържащи транзакции. Транзакцията капсулира набор от
                промени върху определени данни. Шаблонът Command
                предлага начин за моделиране на транзакциите. Командите
                са с общ интерфейс, давайки възможност да бъдат
                извиквани по един и същи начин. Шаблонът улеснява и
                разширяването на системата с нови транзакции.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Command – декларира интерфейс за изпълнение на
                операция.<br>
                - ConcreteCommand<br>
                > дефинира връзка между Receiver обект и действие<br>
                > имплементира Execute чрез извикване на съответните
                операции на Receiver.<br>
                - Client – създава ConcreteCommand обект и задава
                получателя му.<br>
                - Invoker – указва на командата да изпълни заявката.<br>
                - Receiver – знае как да извърши операциите, асоциирани с
                изпълнението на заявката. Всеки клас може да служи за
                Receiver (получател).</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                - Клиентът създава ConcreteCommand обект и задава
                получателя му.<br>
                - Invoker обектът съхранява ConcreteCommand обекта.<br>
                - Invoker обектът издава заявка чрез извикване на
                Execute на командата. Когато командите са с
                възможност за отмяна, ConcreteCommand запазва
                информация, необходима за отмяната, преди да
                извика Execute.<br>
                - ConcreteCommand обектът извиква операция на своя
                получател, за да изпълни заявката.</h3>
            <h3> <span>СЛЕДСТВИЯ:</span><br>
                Шаблонът Command води до следното:
                - Класът Command разделя обекта, извикващ
                операцията, от този, който знае как да я извърши.<br>
                - Командите могат да бъдат манипулирани и
                разширявани както всеки друг обект.<br>
                - Можете лесно да сглобявате множество команди в поголеми сложни команди. По принцип, сложните
                команди са инстанции на шаблона Composition.<br>
                - Добавянето на нови команди е лесно, защото не се
                налага да променяте съществуващите класове.</h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Шаблонът Composition може да бъде използван за
                имплементирането на макрокоманди
                (MacroCommands).<br>
                - Шаблонът Memento може да запазва състоянието,
                необходимо на командата, за да отмени действието
                си.<br>
                - Команда, която трябва да бъде копирана, преди да
                бъде поставена в хронологичен дневник, действа
                като прототип.</h3>
        </div>
        <div class="box">
            <h2>ITERATOR (ИТЕРАТОР)</h2>
            <h3> <span>Цел:</span><br>
                Представя начин за последователен достъп до
                елементите на сложен обект, без да се разкрива
                същинското му представяне.
            </h3>
            <h3> <span>Известен и като:</span><br>
                Cursor (Курсор)</h3>
            <h3> <span>УПОТРЕБА:</span><br>
                Използвайте шаблона Iterator:<br>
                - за да осъществявате достъп до съдържанието на
                структура от данни, бз да разкривате вътрешното му
                представяне<br>
                - за да поддържате множество обхождания на дадена
                структура от данни<br>
                - за да предоставяте унифициран интерфейс за
                обхождане на различни структури от данни.</h3>
            <h3> <span>СТРУКТУРА НА ШАБЛОНА:</span><br>
                - Iterator – дефинира интерфейс за достигане и
                обхождане на елементите.<br>
                - ConcreteIterator<br>
                > имплментира интерфейса на Iterator<br>
                > следи текущата позиция при обхождането на структурата
                от данни.<br>
                - Aggregate – дефинира интерфейс за създаване на
                обект Iterator.<br>
                - ConcreteAggregate – имплементира интерфейса за
                създаване на Iterator, който връща инстанция на
                съответния клас ConcreteIterator.</h3>
            <h3> <span>ВЗАИМОДЕЙСТВИЯ:</span><br>
                ConcreteIterator следи за текущия елемент от
                структурата от данни и може да изчислява
                следващия елемент от обхождането.</h3>
            <h3> <span>ПРЕДИМСТВА И НЕДОСТАТЪЦИ:</span><br>
                Шаблонът Iterator води до 3 важи следствия:<br>
                - Поддържа различни варианти за обхождане на дадена
                структура от данни. Структурите от данни могат да бъдат
                обхождани по много начини. За целта е необходимо да се
                смени инстанцията на итератора. Може да дефинирате
                подкласове на Iterator, за да поддърржате нови начини на
                обхождане.<br>
                - Итераторите опростяват интерфейса на Aggregate.<br>
                Интерфейсът за обхождане на Iterator елиминира нуждата от
                подобен интерфейс в Aggregate, опростявайки по този начин
                интерфейса на структурата от данни.<br>
                - В даден момент може да има повече от едно активно
                обхождане за дадена структура. Итераторът пази в себе си
                текущото състояние на обхождането. Поради това, в даден
                момент можете да извършвате повече от едно обхождане. </h3>
            <h3> <span>ВРЪЗКА С ДРУГИ ШАБЛОНИ:</span><br>
                - Итераторите често се прилагат върху рекурсивни
                структури като Composition.<br>
                - Шаблонът Memory често се използва заедно с
                шаблона Iterator. Iterator може да използва Memory,
                за да пази състоянието на итерацията във вътрешна
                променлива.</h3>
        </div>
    </div>
</body>